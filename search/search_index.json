{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mosaic PAGE STATUS: early draft Introduction Mosaic is a distributed sovereign general-purpose application protocol for the Internet. distributed : There is no central point of failure, or place that can be taken down. There is no central place to \"bootstrap\" Mosaic (other than Mainline DHT's bootstrapping). sovereign : All nodes (users/clients and servers) participation is self-managed and nobody can cancel your account. You manage your own keys. Mosaic does not depend on DNS and Mosaic does not depend on Certification Authorities to issue certificates. general-purpose : Although it started as social media, this architecture has been shown to serve many general-purpose applications. Mosaic is a work in progress . This specification is EARLY DRAFT. What Mosaic is not Mosaic is NOT peer-to-peer : Around the turn of the century, a lot of distributed sovereign protocol work focused on peer-to-peer: Freenet, GnuNET, and later DHTs. As it turns out, peer-to-peer is difficult because most computers are not fully connected to the Internet. And as there is nothing particular difficult in running a server that is fully connected to the Internet (given VPS availability), being strictly peer-to-peer doesn't seem advantageous. So we choose the more rock-solid client-server architecture. Mosaic does NOT provide IP privacy : Around the turn of the century, a lot of distributed sovereign protocol work focused on IP privacy: Freenet, GnuNET, etc. However, Tor took off as a general privacy layer, and other alternatives exist including i2p and VPNs. Architecturally, it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer since Mosaic can run on top of an already existing privacy layer. Where Mosaic came from Mosaic is an offshoot of nostr . Like nostr: Mosaic uses sovereign user-controlled key pairs Mosaic uses WebSockets Mosaic uses client-server architecture, since peer-to-peer has connectivity problems Mosaic doesn't provide IP privacy Unlike nostr: Mosaic uses different cryptography (EdDSA ed25519 and BLAKE3) Mosaic uses subkeys from the start for better key management Mosaic servers have keypair-based identities too, so you can be sure that you are connecting to the right server. Servers are identified by the public key, not their DNS-based URL. Mosaic information (server's IP addresses and user's home server information) is bootstrapped from Mainline DHT Mosaic records are binary. The minimal Mosaic record is 216 bytes, versus the minimal nostr record of 343 byes. The overhead of JSON parsing along with it's ambiguity is gone! Simple tools and library functions can easily convert to/from JSON or indeed any other way you wish to see the data. Mosaic records are editable if an application wants them to be, as all records can be addressed either by their hash (not replaceable) or their address (replaceable) and all records have both a hash and an address. Mosaic WebSockets uses TLS 1.2 or 1.3 with either self-signed certificates or RawPublicKey, so that no dependency is made upon self-proclaimed certificate authority companies. Client authentication by servers is done at the TLS layer where clients also present self-signed or RawPublicKey certificates. Timestamps account for leap seconds (unlike unixtime) and have millisecond accuracy. Clients and Servers remember the time that records are received, so that key revocation can revoke all records received after a certain time, and not rely on the possibly fake timestamps in the records themselves. The specification is layered, and focused on the core. Applications using Mosaic are to be specified in their own respective places. Terminology differences Nostr events are called records Nostr event IDs are called record hashes Nostr relays are called servers The name Mosaic No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"Mosaic Introduction"},{"location":"#mosaic","text":"PAGE STATUS: early draft","title":"Mosaic"},{"location":"#introduction","text":"Mosaic is a distributed sovereign general-purpose application protocol for the Internet. distributed : There is no central point of failure, or place that can be taken down. There is no central place to \"bootstrap\" Mosaic (other than Mainline DHT's bootstrapping). sovereign : All nodes (users/clients and servers) participation is self-managed and nobody can cancel your account. You manage your own keys. Mosaic does not depend on DNS and Mosaic does not depend on Certification Authorities to issue certificates. general-purpose : Although it started as social media, this architecture has been shown to serve many general-purpose applications. Mosaic is a work in progress . This specification is EARLY DRAFT.","title":"Introduction"},{"location":"#what-mosaic-is-not","text":"Mosaic is NOT peer-to-peer : Around the turn of the century, a lot of distributed sovereign protocol work focused on peer-to-peer: Freenet, GnuNET, and later DHTs. As it turns out, peer-to-peer is difficult because most computers are not fully connected to the Internet. And as there is nothing particular difficult in running a server that is fully connected to the Internet (given VPS availability), being strictly peer-to-peer doesn't seem advantageous. So we choose the more rock-solid client-server architecture. Mosaic does NOT provide IP privacy : Around the turn of the century, a lot of distributed sovereign protocol work focused on IP privacy: Freenet, GnuNET, etc. However, Tor took off as a general privacy layer, and other alternatives exist including i2p and VPNs. Architecturally, it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer since Mosaic can run on top of an already existing privacy layer.","title":"What Mosaic is not"},{"location":"#where-mosaic-came-from","text":"Mosaic is an offshoot of nostr . Like nostr: Mosaic uses sovereign user-controlled key pairs Mosaic uses WebSockets Mosaic uses client-server architecture, since peer-to-peer has connectivity problems Mosaic doesn't provide IP privacy Unlike nostr: Mosaic uses different cryptography (EdDSA ed25519 and BLAKE3) Mosaic uses subkeys from the start for better key management Mosaic servers have keypair-based identities too, so you can be sure that you are connecting to the right server. Servers are identified by the public key, not their DNS-based URL. Mosaic information (server's IP addresses and user's home server information) is bootstrapped from Mainline DHT Mosaic records are binary. The minimal Mosaic record is 216 bytes, versus the minimal nostr record of 343 byes. The overhead of JSON parsing along with it's ambiguity is gone! Simple tools and library functions can easily convert to/from JSON or indeed any other way you wish to see the data. Mosaic records are editable if an application wants them to be, as all records can be addressed either by their hash (not replaceable) or their address (replaceable) and all records have both a hash and an address. Mosaic WebSockets uses TLS 1.2 or 1.3 with either self-signed certificates or RawPublicKey, so that no dependency is made upon self-proclaimed certificate authority companies. Client authentication by servers is done at the TLS layer where clients also present self-signed or RawPublicKey certificates. Timestamps account for leap seconds (unlike unixtime) and have millisecond accuracy. Clients and Servers remember the time that records are received, so that key revocation can revoke all records received after a certain time, and not rely on the possibly fake timestamps in the records themselves. The specification is layered, and focused on the core. Applications using Mosaic are to be specified in their own respective places. Terminology differences Nostr events are called records Nostr event IDs are called record hashes Nostr relays are called servers","title":"Where Mosaic came from"},{"location":"#the-name-mosaic","text":"No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"The name Mosaic"},{"location":"blog/","text":"Blog PAGE STATUS: early draft Kind = 0x6 - Blog post Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral. Tags Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7.","title":"Blog"},{"location":"blog/#blog","text":"PAGE STATUS: early draft Kind = 0x6 - Blog post","title":"Blog"},{"location":"blog/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral.","title":"Flags"},{"location":"blog/#tags","text":"Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7.","title":"Tags"},{"location":"bootstrap/","text":"Bootstrap PAGE STATUS: draft When you first find out about a new public key, you may already know if it represents a user or a server (by the context) or you may not even know that. And you also may not know what servers this key uses to host it's key schedule , and profile information, or to publish it's records or receive messages. We store bootstrap records in Mainline DHT. Mainline DHT We use Mainline DHT to store mutable data signed under an ed25519 signature according to BEP 0044 . Rationale: Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It also has this mutable data functionality and works with ed25519 signed data. Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours. Salt We use a salt of \"msb24\" for server bootstrap records and \"mub24\" for user bootstrap records. Rationale: We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap record in the future, and because we have two different kinds of bootstrap records already (this allows a server keypair to also be a user keypair without collision). This salts are short enough to not use too much space. Sequence Numbers Sequence numbers should start at 1 and monotonically increase with each write. Rust code A rust library to access this: https://github.com/pubky/mainline Bootstrap Record Format Bootstrap records (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character (0x0A, \\n). Lines MUST not have trailing whitespace. Two kinds of records may be stored, based on whether the identity represents a server or a user. Server Bootstrap Records Server bootstrap records specify the internet locations (protocol, host and port) that the server is available at. A server bootstrap record starts with the line S . Each subsequent line in a server bootstrap record specifies a URL where the server can be accessed. There can be any number of lines. However, the total length of the data cannot exceed 983 bytes. URLs must contain scheme and host, and may optionally contain a port. URLs must NOT contain user, password, path, query, or fragment sections. If any of those is found in a URL, software MUST prune such information. This includes pruning trailing slashes (which are paths). Only secure transports with TLS are defined. TLS must be version 1.2 or 1.3. The only known schemes currently are wss and https . Here are some examples of server bootstrap record lines: wss://203.0.113.1 specifies WebSockets with TLS on port 80 at IP address 203.0.113.0 . wss://203.0.113.0:5198 specifies WebSockets with TLS on port 5198 at IP address 203.0.113.0 . wss://myserverlk23lkjsefo8u.onion specifies WebSockets with TLS on port 443 over Tor. wss://[2001::130F::09C0:876A:130B] specifies WebSockets with TLS over IPv6 on port 443. https://mosaic.example:555 specifies WebTransport with TLS on port 555 to DNS node mosaic.example (https is to be interpreted as WebTransport, not REST). Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same records as the user bootstrap records. User Bootstrap Records User bootstrap records specify servers that the user uses, and how the user uses them. A user bootstrap record starts with the line U . Each line consists of two parts Server Usage Character This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. Bootstrap records such as the key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits. Server Key The second part is the server's public key, encoded using base64 (using the standard alphabet of RFC 4648). This will be 44 characters long ending in an = symbol. Example Here is an example user bootstrap record: U 1FB42YsY/CV2FqlMrI4CNeaZ2LnCHXzXmmdGKA+UsuBc= 3GQ859t+vK9gfYolOMfGB0VD/+kjk3iGFjxHj0GfhMos= 2L+RDYOrIKID+eEK81510TJ1pQOQW7kMrA10MwKOu0Iw= 3uBpfOVe3ooWMnc1RdMbYKBAIcHlfl2FsQU67lK2CJ8A= 6VKLdex3KykACzM0JpRfduelqwytel1AZGaXuv4sZhfU= Based on size limits of 983 bytes, no more than 20 records can be stored (but see below for other limitations on the number of servers). Should servers become unreliable, users can change servers and update these records at any time. Usage of servers and limits on their number Maximums : Users SHOULD list no more than 4 redundant servers of any kind, since more redundancy provides strongly dimishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first four servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Bootstrap"},{"location":"bootstrap/#bootstrap","text":"PAGE STATUS: draft When you first find out about a new public key, you may already know if it represents a user or a server (by the context) or you may not even know that. And you also may not know what servers this key uses to host it's key schedule , and profile information, or to publish it's records or receive messages. We store bootstrap records in Mainline DHT.","title":"Bootstrap"},{"location":"bootstrap/#mainline-dht","text":"We use Mainline DHT to store mutable data signed under an ed25519 signature according to BEP 0044 . Rationale: Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It also has this mutable data functionality and works with ed25519 signed data. Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours.","title":"Mainline DHT"},{"location":"bootstrap/#salt","text":"We use a salt of \"msb24\" for server bootstrap records and \"mub24\" for user bootstrap records. Rationale: We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap record in the future, and because we have two different kinds of bootstrap records already (this allows a server keypair to also be a user keypair without collision). This salts are short enough to not use too much space.","title":"Salt"},{"location":"bootstrap/#sequence-numbers","text":"Sequence numbers should start at 1 and monotonically increase with each write.","title":"Sequence Numbers"},{"location":"bootstrap/#rust-code","text":"A rust library to access this: https://github.com/pubky/mainline","title":"Rust code"},{"location":"bootstrap/#bootstrap-record-format","text":"Bootstrap records (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character (0x0A, \\n). Lines MUST not have trailing whitespace. Two kinds of records may be stored, based on whether the identity represents a server or a user.","title":"Bootstrap Record Format"},{"location":"bootstrap/#server-bootstrap-records","text":"Server bootstrap records specify the internet locations (protocol, host and port) that the server is available at. A server bootstrap record starts with the line S . Each subsequent line in a server bootstrap record specifies a URL where the server can be accessed. There can be any number of lines. However, the total length of the data cannot exceed 983 bytes. URLs must contain scheme and host, and may optionally contain a port. URLs must NOT contain user, password, path, query, or fragment sections. If any of those is found in a URL, software MUST prune such information. This includes pruning trailing slashes (which are paths). Only secure transports with TLS are defined. TLS must be version 1.2 or 1.3. The only known schemes currently are wss and https . Here are some examples of server bootstrap record lines: wss://203.0.113.1 specifies WebSockets with TLS on port 80 at IP address 203.0.113.0 . wss://203.0.113.0:5198 specifies WebSockets with TLS on port 5198 at IP address 203.0.113.0 . wss://myserverlk23lkjsefo8u.onion specifies WebSockets with TLS on port 443 over Tor. wss://[2001::130F::09C0:876A:130B] specifies WebSockets with TLS over IPv6 on port 443. https://mosaic.example:555 specifies WebTransport with TLS on port 555 to DNS node mosaic.example (https is to be interpreted as WebTransport, not REST). Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same records as the user bootstrap records.","title":"Server Bootstrap Records"},{"location":"bootstrap/#user-bootstrap-records","text":"User bootstrap records specify servers that the user uses, and how the user uses them. A user bootstrap record starts with the line U . Each line consists of two parts","title":"User Bootstrap Records"},{"location":"bootstrap/#server-usage-character","text":"This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. Bootstrap records such as the key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits.","title":"Server Usage Character"},{"location":"bootstrap/#server-key","text":"The second part is the server's public key, encoded using base64 (using the standard alphabet of RFC 4648). This will be 44 characters long ending in an = symbol.","title":"Server Key"},{"location":"bootstrap/#example","text":"Here is an example user bootstrap record: U 1FB42YsY/CV2FqlMrI4CNeaZ2LnCHXzXmmdGKA+UsuBc= 3GQ859t+vK9gfYolOMfGB0VD/+kjk3iGFjxHj0GfhMos= 2L+RDYOrIKID+eEK81510TJ1pQOQW7kMrA10MwKOu0Iw= 3uBpfOVe3ooWMnc1RdMbYKBAIcHlfl2FsQU67lK2CJ8A= 6VKLdex3KykACzM0JpRfduelqwytel1AZGaXuv4sZhfU= Based on size limits of 983 bytes, no more than 20 records can be stored (but see below for other limitations on the number of servers). Should servers become unreliable, users can change servers and update these records at any time.","title":"Example"},{"location":"bootstrap/#usage-of-servers-and-limits-on-their-number","text":"Maximums : Users SHOULD list no more than 4 redundant servers of any kind, since more redundancy provides strongly dimishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first four servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Usage of servers and limits on their number"},{"location":"chat/","text":"Chat PAGE STATUS: early draft Kind = 0x7 - chat message Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on Tags This MAY include up to one refer tag, either 0x6 or 0x7.","title":"Chat"},{"location":"chat/#chat","text":"PAGE STATUS: early draft Kind = 0x7 - chat message","title":"Chat"},{"location":"chat/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on","title":"Flags"},{"location":"chat/#tags","text":"This MAY include up to one refer tag, either 0x6 or 0x7.","title":"Tags"},{"location":"cryptography/","text":"Cryptography PAGE STATUS: early draft Hashing We use BLAKE3 in unkeyed hashing mode, producing a 512-bit digest. Rationale: This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and is about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. Yes 512-bits is a lot. But EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes anyways. We can always refer to events with a hash prefix. Alternative: Use the 512-bits in EdDSA ed25519, but only store the 256-bit prefix of that hash (BLAKE3 hashes are variable size, and smaller hashes are prefixes of larger hashes). Digital Signature We use EdDSA with the ed25519 curve and very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1. Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Rationale: Fast and space efficient Widely studied Very good resistance to side-channel attacks Does not require point validation In our form, provides the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature Interoperates with TLS, Mainline DHT, and other modern ed25519-based identity systems See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice Encryption Records in Mosaic are generally not encrypted, but public things. However some applications have a need to encrypt data. This is a general specification of how encryption is done. Encryption details are still TBD but we intend: To use ECIES To do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. We recommend using an encryption-only subkey pair for this purpose, which is not used in ed25519 signing. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Cryptography"},{"location":"cryptography/#cryptography","text":"PAGE STATUS: early draft","title":"Cryptography"},{"location":"cryptography/#hashing","text":"We use BLAKE3 in unkeyed hashing mode, producing a 512-bit digest. Rationale: This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and is about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. Yes 512-bits is a lot. But EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes anyways. We can always refer to events with a hash prefix. Alternative: Use the 512-bits in EdDSA ed25519, but only store the 256-bit prefix of that hash (BLAKE3 hashes are variable size, and smaller hashes are prefixes of larger hashes).","title":"Hashing"},{"location":"cryptography/#digital-signature","text":"We use EdDSA with the ed25519 curve and very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1. Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Rationale: Fast and space efficient Widely studied Very good resistance to side-channel attacks Does not require point validation In our form, provides the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature Interoperates with TLS, Mainline DHT, and other modern ed25519-based identity systems See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice","title":"Digital Signature"},{"location":"cryptography/#encryption","text":"Records in Mosaic are generally not encrypted, but public things. However some applications have a need to encrypt data. This is a general specification of how encryption is done. Encryption details are still TBD but we intend: To use ECIES To do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. We recommend using an encryption-only subkey pair for this purpose, which is not used in ed25519 signing. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Encryption"},{"location":"filter/","text":"Filter PAGE STATUS: early draft A filter is a binary record that is up to 65536 bytes long maximum. It is defined as a contiguous sequence of type-value pairs. Some types specify a count or length within their value. Hash16 - Type 0x1 The byte 0x1 A 1-byte count (n), then A sequence of n 16-byte, 128-bit hash prefixes. This matches up to 256 specific records (as hashes are unique). Hash32 - Type 0x2 The byte 0x2 A 1-byte count (n), then A sequence of n 32-byte, 128-bit hash prefixes. This matches up to 256 specific records (as hashes are unique). Author Keys - Type 0x3 The byte 0x3 A 1-byte count (n), then A sequence of n 32-byte author public keys. This matches all records authored by up to 256 different users. Signing Keys - Type 0x4 The byte 0x4 A 1-byte count (n), then A sequence of n 32-byte signing public keys. This matches all records signed by up to 256 different signing keys. Timestamps - Type 0x5 The byte 0x5 A 1-byte count (n), then A sequence of n 6-byte timestamps . This matches all records that have any of these exact timestamps. Since - Type 0x6 The byte 0x6 A 6-byte timestamp This matches all records with a timestamp greater than or equal to its value. Until - Type 0x7 The byte 0x7 A 6-byte timestamp This matches all records with a timestamp less than its value. Received Ats - 0x8 The byte 0x8 A 1-byte count (n), then A sequence of n 6-byte timestamps . This matches all records that were received by the server at any of these exact timestamps. Received Since - Type 0x9 The byte 0x9 A 6-byte timestamp This matches all records that were received by the server at or later than its value. Received Until - Type 0xA The byte 0xA A 6-byte timestamp This matches all records that were received by the server before its value. Kinds - Type 0xB The byte 0xB A 1-byte count (n), then A sequence of n 4-byte kinds This matches all records which are of one of these kinds. Tag Values - Type 0xC The byte 0xC A 1-byte count (n), then A 2-byte tag type A sequence of n pairs of (1-byte-length, value) representing the n values which cause the filter to match.","title":"Filter"},{"location":"filter/#filter","text":"PAGE STATUS: early draft A filter is a binary record that is up to 65536 bytes long maximum. It is defined as a contiguous sequence of type-value pairs. Some types specify a count or length within their value.","title":"Filter"},{"location":"filter/#hash16-type-0x1","text":"The byte 0x1 A 1-byte count (n), then A sequence of n 16-byte, 128-bit hash prefixes. This matches up to 256 specific records (as hashes are unique).","title":"Hash16 - Type 0x1"},{"location":"filter/#hash32-type-0x2","text":"The byte 0x2 A 1-byte count (n), then A sequence of n 32-byte, 128-bit hash prefixes. This matches up to 256 specific records (as hashes are unique).","title":"Hash32 - Type 0x2"},{"location":"filter/#author-keys-type-0x3","text":"The byte 0x3 A 1-byte count (n), then A sequence of n 32-byte author public keys. This matches all records authored by up to 256 different users.","title":"Author Keys - Type 0x3"},{"location":"filter/#signing-keys-type-0x4","text":"The byte 0x4 A 1-byte count (n), then A sequence of n 32-byte signing public keys. This matches all records signed by up to 256 different signing keys.","title":"Signing Keys - Type 0x4"},{"location":"filter/#timestamps-type-0x5","text":"The byte 0x5 A 1-byte count (n), then A sequence of n 6-byte timestamps . This matches all records that have any of these exact timestamps.","title":"Timestamps - Type 0x5"},{"location":"filter/#since-type-0x6","text":"The byte 0x6 A 6-byte timestamp This matches all records with a timestamp greater than or equal to its value.","title":"Since - Type 0x6"},{"location":"filter/#until-type-0x7","text":"The byte 0x7 A 6-byte timestamp This matches all records with a timestamp less than its value.","title":"Until - Type 0x7"},{"location":"filter/#received-ats-0x8","text":"The byte 0x8 A 1-byte count (n), then A sequence of n 6-byte timestamps . This matches all records that were received by the server at any of these exact timestamps.","title":"Received Ats - 0x8"},{"location":"filter/#received-since-type-0x9","text":"The byte 0x9 A 6-byte timestamp This matches all records that were received by the server at or later than its value.","title":"Received Since - Type 0x9"},{"location":"filter/#received-until-type-0xa","text":"The byte 0xA A 6-byte timestamp This matches all records that were received by the server before its value.","title":"Received Until - Type 0xA"},{"location":"filter/#kinds-type-0xb","text":"The byte 0xB A 1-byte count (n), then A sequence of n 4-byte kinds This matches all records which are of one of these kinds.","title":"Kinds - Type 0xB"},{"location":"filter/#tag-values-type-0xc","text":"The byte 0xC A 1-byte count (n), then A 2-byte tag type A sequence of n pairs of (1-byte-length, value) representing the n values which cause the filter to match.","title":"Tag Values - Type 0xC"},{"location":"identity/","text":"Identity PAGE STATUS: early draft Users and Servers Identities are split between Users and Servers. Users in Mosaic are self-created and self-administered. This puts each user in control of their own account, allowing them to digitally sign their content, move to different servers and not to rely on any central service or authority. This however also requires each end user to securely manage their private key material. Convenient methods for doing so, as well as recovery, are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or perhaps managed by a trusted service. Public key cryptosystem keypair Identities are realized as a keypair produced within a public key cryptosystem. We use the EdDSA ed25519 cryptosystem for digital signature. See cryptography . A user is identified by their ed25519 master public key. Master keys and Subkeys Users may have subsidiary public keys, known as subkeys . At times this may also be called signing keys or device keys . The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or nostr secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing or modifying a user's key schedule with new keys and/or revocations. Publishing or modifying a user's server list Publishing or modifying a user's profile record Subkeys might be deterministically derived from the master private key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Identity"},{"location":"identity/#identity","text":"PAGE STATUS: early draft","title":"Identity"},{"location":"identity/#users-and-servers","text":"Identities are split between Users and Servers. Users in Mosaic are self-created and self-administered. This puts each user in control of their own account, allowing them to digitally sign their content, move to different servers and not to rely on any central service or authority. This however also requires each end user to securely manage their private key material. Convenient methods for doing so, as well as recovery, are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or perhaps managed by a trusted service.","title":"Users and Servers"},{"location":"identity/#public-key-cryptosystem-keypair","text":"Identities are realized as a keypair produced within a public key cryptosystem. We use the EdDSA ed25519 cryptosystem for digital signature. See cryptography . A user is identified by their ed25519 master public key.","title":"Public key cryptosystem keypair"},{"location":"identity/#master-keys-and-subkeys","text":"Users may have subsidiary public keys, known as subkeys . At times this may also be called signing keys or device keys . The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or nostr secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing or modifying a user's key schedule with new keys and/or revocations. Publishing or modifying a user's server list Publishing or modifying a user's profile record Subkeys might be deterministically derived from the master private key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Master keys and Subkeys"},{"location":"keyschedule/","text":"Key Schedule Record PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has kind 0x1. A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical. Tags Every subkey listed in a key schedule record must have an associated Subkey tag listing the subkey. Payload `The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Subkey 1/4 | 8 +-------------------------------+ | Subkey 2/4 | 16 +-------------------------------+ | Subkey 3/4 | 24 +-------------------------------+ | Subkey 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ Marker [32:33] is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. Res [33:34] is 1-byte and is reserved. It MUST be 0. Timestamp [34:40] is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases.","title":"Key Schedule"},{"location":"keyschedule/#key-schedule-record","text":"PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has kind 0x1. A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical.","title":"Key Schedule Record"},{"location":"keyschedule/#tags","text":"Every subkey listed in a key schedule record must have an associated Subkey tag listing the subkey.","title":"Tags"},{"location":"keyschedule/#payload","text":"`The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Subkey 1/4 | 8 +-------------------------------+ | Subkey 2/4 | 16 +-------------------------------+ | Subkey 3/4 | 24 +-------------------------------+ | Subkey 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ Marker [32:33] is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. Res [33:34] is 1-byte and is reserved. It MUST be 0. Timestamp [34:40] is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases.","title":"Payload"},{"location":"kinds/","text":"Record Kinds PAGE STATUS: Early Draft Kinds are 4-byte unsigned integers in little-endian format. This page is a Registry of kinds, their name, and the standard that defines them. Refer to their definitions in the standards that define them. Kind Name Standard 0x1 Key Schedule Mosiac Core Key Schedule 0x2 Profile Mosaic Core Profile 0x3 Microblog Root Mosaic Social Media Microblog Root 0x4 Reply Comment Mosaic Social Media Reply Comment 0x5 Blog Post Mosaic Social Media Blog Post 0x6 Chat Message Mosaic Social Media Chat Message","title":"Record Kinds"},{"location":"kinds/#record-kinds","text":"PAGE STATUS: Early Draft Kinds are 4-byte unsigned integers in little-endian format. This page is a Registry of kinds, their name, and the standard that defines them. Refer to their definitions in the standards that define them. Kind Name Standard 0x1 Key Schedule Mosiac Core Key Schedule 0x2 Profile Mosaic Core Profile 0x3 Microblog Root Mosaic Social Media Microblog Root 0x4 Reply Comment Mosaic Social Media Reply Comment 0x5 Blog Post Mosaic Social Media Blog Post 0x6 Chat Message Mosaic Social Media Chat Message","title":"Record Kinds"},{"location":"microblog/","text":"Microblog PAGE STATUS: incomplete Kind = 0x4 - Root Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Microblogging"},{"location":"microblog/#microblog","text":"PAGE STATUS: incomplete Kind = 0x4 - Root","title":"Microblog"},{"location":"microblog/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"profile/","text":"Profile Record PAGE STATUS: TBD A profile record contains user profile information. A profile record has kind 0x2.","title":"Profile"},{"location":"profile/#profile-record","text":"PAGE STATUS: TBD A profile record contains user profile information. A profile record has kind 0x2.","title":"Profile Record"},{"location":"protocol/","text":"Protocol PAGE STATUS: early draft Protocol message are not separately digitally signed due to the TLS transport and certificate authentication. Protocol Extensions Protocol extension negotiation is done on a transport-by-transport level. For WebSockets transport (the default) this is done with the X-Mosaic-Extensions header. The following extensions have been defined: Sync Protocol Extension Messages Every message starts with a one-byte type, shown below in the header of each type. Following this is the data of the message. Client messages Query 0x1 This is a query for records in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x1 | QUERY_ID | 0x0 | +-------------------------------+ | FILTER LEN | 0x0 | +-------------------------------+ | FILTER ... | | ... | +-------------------------------+ The QUERY_ID should be made up by the client. It can be any 16-bit number and is used for associating responses. FILTER_LEN is a 16-bit little-endian integer indicating the length of the filter. The FILTER is defined in filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Query Complete message, potentially followed by zero or more Record messages that flow in to the server after the initial response (so long as the query is still open), or a Query Closed message if the query could not be served. Close Query 0x2 This is a client request to close a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x2 | QUERY_ID | 0x0 | +-------------------------------+ This is a client initiated message. Servers are expected to reply with: Query Closed Submission 0x3 This is the submission of a record in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x3 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record submitted. RECORD is the record. This is a client initiated message. Servers are expected to reply with: Submission Result with a hash prefix matching the record. Server messages Record 0x80 This is a record returned from a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x80 | QUERY_ID | 0x0 | +-------------------------------+ | 0x0 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ The QUERY_ID is the client query that this record matched. The LENGTH is the length of the record as a 24-bit little-endian encoded value. The RECORD is the actual record This is a server response message in response to Query . Query Complete 0x81 This is a message indicating that a query is complete, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x81 | QUERY_ID | 0x0 | +-------------------------------+ This indicates that a query is complete. This does not mean the query will close, as subsequently received records that match the query will be subsequently returned. This is a server response message in response to Query . Query Closed 0x82 This is a message indicating that a query has been closed, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x82 | QUERY_ID | CODE | +-------------------------------+ The QUERY_ID is the client query that is being closed that was previously supplied by the client in a Query . The CODE indicates the reason for closure, from among the following defined reasons. ON_REQUEST : 0x1 - In response to Close REJECTED_INVALID : 0x10 - Query was rejected due to being invalid REJECTED_TOO_OPEN : 0x11 - Query was rejected due to being too open (scraping too many records) REJECTED_TOO_FAST : 0x12 - Query was rejected due to too many queries (or messages of any type) being submitted recently by this client REJECTED_TEMP_BANNED : 0x13 - Query was rejected due to the client beint temporarily banned REJECTED_PERM_BANNED : 0x14 - Query was rejected due to the client beint permanently banned SHUTTING_DOWN : 0x30 - The server is shutting down INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason Submission Result 0x83 This is a message returning the result of a Submission in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x82 | 0x0 | 0x0 | CODE | +-------------------------------+ | HASH PREFIX 1/8 | +-------------------------------+ | HASH PREFIX 2/8 | +-------------------------------+ | HASH PREFIX 3/8 | +-------------------------------+ | HASH PREFIX 4/8 | +-------------------------------+ | HASH PREFIX 5/8 | +-------------------------------+ | HASH PREFIX 6/8 | +-------------------------------+ | HASH PREFIX 7/8 | +-------------------------------+ | HASH PREFIX 8/8 | +-------------------------------+ The CODE indicates the result of the submission from among the following defined results: OK : 0x1 - Record submission was accepted DUPLICATE : 0x2 - Record is a duplicate. Servers may use this or they may optionally use OK in the same circumstance. REJECTED_INVALID : 0x10 - Record is invalid REJECTED_TOO_FAST : 0x12 - Record submission was rejected due to too many submissions (or messages of any type) being made recently by this client REJECTED_TEMP_BANNED : 0x13 - Record submission was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Record submission was rejected due to the client being permanently banned REJECTED_REQUIRES_AUTHN : 0x15 - Record submission requires authentication but the client is connected anonymously. REJECTED_REQUIRES_AUTHZ : 0x16 - Record submission requires authorization (e.g. an account with the server) which the client user does not have. INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason FIXME: add proof of work (not defined yet) The HASH_PREFIX is the first 256-bits of the event hash.","title":"Protocol"},{"location":"protocol/#protocol","text":"PAGE STATUS: early draft Protocol message are not separately digitally signed due to the TLS transport and certificate authentication.","title":"Protocol"},{"location":"protocol/#protocol-extensions","text":"Protocol extension negotiation is done on a transport-by-transport level. For WebSockets transport (the default) this is done with the X-Mosaic-Extensions header. The following extensions have been defined: Sync Protocol Extension","title":"Protocol Extensions"},{"location":"protocol/#messages","text":"Every message starts with a one-byte type, shown below in the header of each type. Following this is the data of the message.","title":"Messages"},{"location":"protocol/#client-messages","text":"","title":"Client messages"},{"location":"protocol/#query","text":"0x1 This is a query for records in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x1 | QUERY_ID | 0x0 | +-------------------------------+ | FILTER LEN | 0x0 | +-------------------------------+ | FILTER ... | | ... | +-------------------------------+ The QUERY_ID should be made up by the client. It can be any 16-bit number and is used for associating responses. FILTER_LEN is a 16-bit little-endian integer indicating the length of the filter. The FILTER is defined in filter . This is a client initiated message. Servers are expected to reply with: a series of zero or more Record messages representing all the matching records on the server initially, followed by a Query Complete message, potentially followed by zero or more Record messages that flow in to the server after the initial response (so long as the query is still open), or a Query Closed message if the query could not be served.","title":"Query"},{"location":"protocol/#close-query","text":"0x2 This is a client request to close a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x2 | QUERY_ID | 0x0 | +-------------------------------+ This is a client initiated message. Servers are expected to reply with: Query Closed","title":"Close Query"},{"location":"protocol/#submission","text":"0x3 This is the submission of a record in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x3 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ LENGTH is a 24-bit little-endian length, with a maximum value of the max length of a record (1024576 bytes) and representing the actual length of the subsequent record submitted. RECORD is the record. This is a client initiated message. Servers are expected to reply with: Submission Result with a hash prefix matching the record.","title":"Submission"},{"location":"protocol/#server-messages","text":"","title":"Server messages"},{"location":"protocol/#record","text":"0x80 This is a record returned from a query in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x80 | QUERY_ID | 0x0 | +-------------------------------+ | 0x0 | LENGTH | +-------------------------------+ | RECORD ... | | ... | +-------------------------------+ The QUERY_ID is the client query that this record matched. The LENGTH is the length of the record as a 24-bit little-endian encoded value. The RECORD is the actual record This is a server response message in response to Query .","title":"Record"},{"location":"protocol/#query-complete","text":"0x81 This is a message indicating that a query is complete, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x81 | QUERY_ID | 0x0 | +-------------------------------+ This indicates that a query is complete. This does not mean the query will close, as subsequently received records that match the query will be subsequently returned. This is a server response message in response to Query .","title":"Query Complete"},{"location":"protocol/#query-closed","text":"0x82 This is a message indicating that a query has been closed, in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x82 | QUERY_ID | CODE | +-------------------------------+ The QUERY_ID is the client query that is being closed that was previously supplied by the client in a Query . The CODE indicates the reason for closure, from among the following defined reasons. ON_REQUEST : 0x1 - In response to Close REJECTED_INVALID : 0x10 - Query was rejected due to being invalid REJECTED_TOO_OPEN : 0x11 - Query was rejected due to being too open (scraping too many records) REJECTED_TOO_FAST : 0x12 - Query was rejected due to too many queries (or messages of any type) being submitted recently by this client REJECTED_TEMP_BANNED : 0x13 - Query was rejected due to the client beint temporarily banned REJECTED_PERM_BANNED : 0x14 - Query was rejected due to the client beint permanently banned SHUTTING_DOWN : 0x30 - The server is shutting down INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason","title":"Query Closed"},{"location":"protocol/#submission-result","text":"0x83 This is a message returning the result of a Submission in the following format: 1 2 3 0 8 6 4 2 0 +-------------------------------+ | 0x82 | 0x0 | 0x0 | CODE | +-------------------------------+ | HASH PREFIX 1/8 | +-------------------------------+ | HASH PREFIX 2/8 | +-------------------------------+ | HASH PREFIX 3/8 | +-------------------------------+ | HASH PREFIX 4/8 | +-------------------------------+ | HASH PREFIX 5/8 | +-------------------------------+ | HASH PREFIX 6/8 | +-------------------------------+ | HASH PREFIX 7/8 | +-------------------------------+ | HASH PREFIX 8/8 | +-------------------------------+ The CODE indicates the result of the submission from among the following defined results: OK : 0x1 - Record submission was accepted DUPLICATE : 0x2 - Record is a duplicate. Servers may use this or they may optionally use OK in the same circumstance. REJECTED_INVALID : 0x10 - Record is invalid REJECTED_TOO_FAST : 0x12 - Record submission was rejected due to too many submissions (or messages of any type) being made recently by this client REJECTED_TEMP_BANNED : 0x13 - Record submission was rejected due to the client being temporarily banned REJECTED_PERM_BANNED : 0x14 - Record submission was rejected due to the client being permanently banned REJECTED_REQUIRES_AUTHN : 0x15 - Record submission requires authentication but the client is connected anonymously. REJECTED_REQUIRES_AUTHZ : 0x16 - Record submission requires authorization (e.g. an account with the server) which the client user does not have. INTERNAL_ERROR : 0xF0 - A server error occured OTHER : 0xFF - Some other reason FIXME: add proof of work (not defined yet) The HASH_PREFIX is the first 256-bits of the event hash.","title":"Submission Result"},{"location":"record/","text":"Record PAGE STATUS: draft FIXME: The exact length of the tags and payload sections are not known, only to 8-bit word cutoff. We should add 6 bits to express the exact length of the data minus the padding... possibly at the reserved area... possibly swap that with flags. A record is a datum within Mosaic. All datums are records. Notation Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11. Maximum Size The maximum size of a record is 1 mebibyte (1,048,576 bytes). This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes. Layout Note that records are laid out in a way to provide 64-bit alignment. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | +-------------------------------+ | Signature 2/8 | +-------------------------------+ | Signature 3/8 | +-------------------------------+ | Signature 4/8 | +-------------------------------+ | Signature 5/8 | +-------------------------------+ | Signature 6/8 | +-------------------------------+ | Signature 7/8 | +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ | Hash 1/4 | +-------------------------------+ | Hash 2/4 | +-------------------------------+ | Hash 3/4 | +-------------------------------+ | Hash 4/4 | 96 +-------------------------------+ | Hash 5/5 | +-------------------------------+ | Hash 6/6 | +-------------------------------+ | Hash 7/7 | +-------------------------------+ | Hash 8/8 | 128 +-------------------------------+ | Signing public key, 1/4 | +-------------------------------+ | Signing public key, 2/4 | +-------------------------------+ | Signing public key, 3/4 | +-------------------------------+ | Signing public key, 4/4 | 160 +-------------------------------+ | Author public key, 1/4 | +-------------------------------+ | Author public key, 2/4 | +-------------------------------+ | Author public key, 3/4 | +-------------------------------+ | Author public key, 4/4 | 192 +-------------------------------+ | Timestamp | Nonce | 200 +-------------------------------+ | ... Nonce | Kind | 208 +-------------------------------+ | Len_t | Len_p |FLAGS |RESERVED| 216 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+ Fields Records contain the following fields. See the layout section for the binary layout of these fields within a record. Signature 64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature using the 64-byte hash at [64:128] . ph means \"pre hashed\" (we will hash the content with BLAKE3 and tell EdDSA that it is a SHA-512 hash of the message). We also provide a context to this algorithm of b\"Mosaic\"; This signature is made with the Signing private key and is represented in 64 bytes. Rationale: EdDSA uses a SHA-512 hashing internal to the algorithm. But BLAKE3 is a faster especially for longer messages, and EdDSA works just fine with it. We provide a context so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application). Hash 64 bytes at [64:128] The hashing function is BLAKE3, unkeyed. We use the finalize_xof() function to extend the output from the default 256-bits up to 512 bits. This input of the hash is all the data starting at byte 128, [128:] , everything except the signature and hash itself. Signing Public Key 32 bytes at [128:160] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). This is represented in 32 bytes (256 bits). Author Public Key 32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair, which is represented in 32 bytes (256 bits). Timestamp 6 bytes at [192:198] This is a timestamp represented in 6 bytes (48 bits) according to timestamps . Nonce 6 bytes at [198:204] This is represented in 6 bytes (48 bits). These are randomly generated (except in the case of record replacement, where they are copied from the prior record). The purpose of the nonce is to ensure that address-based references are unique. See References . Kind 4 bytes at [204:208] This is the kind of the record which is application specific, and determines the nature of the payload, represented in 4 bytes (32 bits) as an unsigned integer, little-endian. Len_t 2 bytes at [208:210] representing the length of the tags section divided by 8, as an unsigned integer in litte-endian format. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes. Len_p 2 bytes at [210:212] representing the length of the payload section divided by 8, as an unsigned integer in little-endian format. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes. Flags 2 bytes at [212:214] Reserved flags MUST be set to 0. 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED 0x40 - RESERVED 0x80 - RESERVED 0x100 - RESERVED 0x200 - RESERVED 0x400 - RESERVED 0x800 - RESERVED 0x1000 - RESERVED 0x2000 - RESERVED 0x4000 - RESERVED 0x8000 - RESERVED Reserved 2 bytes at [214:216] This Reserved space MUST be set to 0. Tags Varying bytes at [216:216+Len_t] These are searchable key-value tags. Unlike nostr tags, all of thsese are searchable. If an application requires unsearchable tags, these can be defined within that application's payload. Each tag has a 2 byte (16 bit) type and a value that is at most 253 bytes long. Tags are laid out as follows: +-------+---------+---------+ | type | length | value | +-------+---------+---------+ where the type is 2 bytes (16 bits) and the length is 1 byte (8 bits) and represents the length of the value, and the value is at most 253 bytes long. Tags only have one value. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes. Tag types are documented at Core tags Rationale: Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes. Payload Varying bytes at [216+Len_t:216+Len_t+Len_p]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes.","title":"Record"},{"location":"record/#record","text":"PAGE STATUS: draft FIXME: The exact length of the tags and payload sections are not known, only to 8-bit word cutoff. We should add 6 bits to express the exact length of the data minus the padding... possibly at the reserved area... possibly swap that with flags. A record is a datum within Mosaic. All datums are records.","title":"Record"},{"location":"record/#notation","text":"Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11.","title":"Notation"},{"location":"record/#maximum-size","text":"The maximum size of a record is 1 mebibyte (1,048,576 bytes). This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes.","title":"Maximum Size"},{"location":"record/#layout","text":"Note that records are laid out in a way to provide 64-bit alignment. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | +-------------------------------+ | Signature 2/8 | +-------------------------------+ | Signature 3/8 | +-------------------------------+ | Signature 4/8 | +-------------------------------+ | Signature 5/8 | +-------------------------------+ | Signature 6/8 | +-------------------------------+ | Signature 7/8 | +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ | Hash 1/4 | +-------------------------------+ | Hash 2/4 | +-------------------------------+ | Hash 3/4 | +-------------------------------+ | Hash 4/4 | 96 +-------------------------------+ | Hash 5/5 | +-------------------------------+ | Hash 6/6 | +-------------------------------+ | Hash 7/7 | +-------------------------------+ | Hash 8/8 | 128 +-------------------------------+ | Signing public key, 1/4 | +-------------------------------+ | Signing public key, 2/4 | +-------------------------------+ | Signing public key, 3/4 | +-------------------------------+ | Signing public key, 4/4 | 160 +-------------------------------+ | Author public key, 1/4 | +-------------------------------+ | Author public key, 2/4 | +-------------------------------+ | Author public key, 3/4 | +-------------------------------+ | Author public key, 4/4 | 192 +-------------------------------+ | Timestamp | Nonce | 200 +-------------------------------+ | ... Nonce | Kind | 208 +-------------------------------+ | Len_t | Len_p |FLAGS |RESERVED| 216 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+","title":"Layout"},{"location":"record/#fields","text":"Records contain the following fields. See the layout section for the binary layout of these fields within a record.","title":"Fields"},{"location":"record/#signature","text":"64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature using the 64-byte hash at [64:128] . ph means \"pre hashed\" (we will hash the content with BLAKE3 and tell EdDSA that it is a SHA-512 hash of the message). We also provide a context to this algorithm of b\"Mosaic\"; This signature is made with the Signing private key and is represented in 64 bytes. Rationale: EdDSA uses a SHA-512 hashing internal to the algorithm. But BLAKE3 is a faster especially for longer messages, and EdDSA works just fine with it. We provide a context so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application).","title":"Signature"},{"location":"record/#hash","text":"64 bytes at [64:128] The hashing function is BLAKE3, unkeyed. We use the finalize_xof() function to extend the output from the default 256-bits up to 512 bits. This input of the hash is all the data starting at byte 128, [128:] , everything except the signature and hash itself.","title":"Hash"},{"location":"record/#signing-public-key","text":"32 bytes at [128:160] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). This is represented in 32 bytes (256 bits).","title":"Signing Public Key"},{"location":"record/#author-public-key","text":"32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair, which is represented in 32 bytes (256 bits).","title":"Author Public Key"},{"location":"record/#timestamp","text":"6 bytes at [192:198] This is a timestamp represented in 6 bytes (48 bits) according to timestamps .","title":"Timestamp"},{"location":"record/#nonce","text":"6 bytes at [198:204] This is represented in 6 bytes (48 bits). These are randomly generated (except in the case of record replacement, where they are copied from the prior record). The purpose of the nonce is to ensure that address-based references are unique. See References .","title":"Nonce"},{"location":"record/#kind","text":"4 bytes at [204:208] This is the kind of the record which is application specific, and determines the nature of the payload, represented in 4 bytes (32 bits) as an unsigned integer, little-endian.","title":"Kind"},{"location":"record/#len_t","text":"2 bytes at [208:210] representing the length of the tags section divided by 8, as an unsigned integer in litte-endian format. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes.","title":"Len_t"},{"location":"record/#len_p","text":"2 bytes at [210:212] representing the length of the payload section divided by 8, as an unsigned integer in little-endian format. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes.","title":"Len_p"},{"location":"record/#flags","text":"2 bytes at [212:214] Reserved flags MUST be set to 0. 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED 0x40 - RESERVED 0x80 - RESERVED 0x100 - RESERVED 0x200 - RESERVED 0x400 - RESERVED 0x800 - RESERVED 0x1000 - RESERVED 0x2000 - RESERVED 0x4000 - RESERVED 0x8000 - RESERVED","title":"Flags"},{"location":"record/#reserved","text":"2 bytes at [214:216] This Reserved space MUST be set to 0.","title":"Reserved"},{"location":"record/#tags","text":"Varying bytes at [216:216+Len_t] These are searchable key-value tags. Unlike nostr tags, all of thsese are searchable. If an application requires unsearchable tags, these can be defined within that application's payload. Each tag has a 2 byte (16 bit) type and a value that is at most 253 bytes long. Tags are laid out as follows: +-------+---------+---------+ | type | length | value | +-------+---------+---------+ where the type is 2 bytes (16 bits) and the length is 1 byte (8 bits) and represents the length of the value, and the value is at most 253 bytes long. Tags only have one value. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes. Tag types are documented at Core tags Rationale: Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes.","title":"Tags"},{"location":"record/#payload","text":"Varying bytes at [216+Len_t:216+Len_t+Len_p]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes.","title":"Payload"},{"location":"reference/","text":"References PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references Hash Reference A hash reference is a pointer to an exact record with no provision for replacement or edits. It is a prefix of the hash of the message. Usually either a 16-byte (128 bit) or 32-byte (256 bit) prefix is used. Address Reference An address reference is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records. An address consists of four fields which are contiguous and in order in the record layout at [160:208] making up 48 bytes. The the author's public key (32 bytes), The timestamp (6 bytes), The nonce (6 bytes The kind (4 bytes). An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key, the same timestamp, and the same kind. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed. Rationale: By containing the Author public key, record location can be determined through bootstrapping . These are 48 bytes long and easily fit into a 253 byte tag when needed. By not including the hash of content, records can be edited and replaced by the author (where edits make sense) By containing the kind, records that are edited cannot change their kind. By containing the kind, software can filter records that are not relevant to a situation without needing to look them up first. 48 bits of randomness (in the nonce) is unique enough. The odds that a user will have multiple clients that simultaneously create records at the same millisecond and also choose the same 48-bit random number is exceedingly low given that the odds of choosing the same 48-bit random number is about 1 in 281 trillion. Normally people use 64-bit random numbers for global uniqueness, but we don't need global uniqueness, just unique for the given author at that precise millisecond in time. These addresses sort in chronological order, per author.","title":"Reference"},{"location":"reference/#references","text":"PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references","title":"References"},{"location":"reference/#hash-reference","text":"A hash reference is a pointer to an exact record with no provision for replacement or edits. It is a prefix of the hash of the message. Usually either a 16-byte (128 bit) or 32-byte (256 bit) prefix is used.","title":"Hash Reference"},{"location":"reference/#address-reference","text":"An address reference is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records. An address consists of four fields which are contiguous and in order in the record layout at [160:208] making up 48 bytes. The the author's public key (32 bytes), The timestamp (6 bytes), The nonce (6 bytes The kind (4 bytes). An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key, the same timestamp, and the same kind. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed. Rationale: By containing the Author public key, record location can be determined through bootstrapping . These are 48 bytes long and easily fit into a 253 byte tag when needed. By not including the hash of content, records can be edited and replaced by the author (where edits make sense) By containing the kind, records that are edited cannot change their kind. By containing the kind, software can filter records that are not relevant to a situation without needing to look them up first. 48 bits of randomness (in the nonce) is unique enough. The odds that a user will have multiple clients that simultaneously create records at the same millisecond and also choose the same 48-bit random number is exceedingly low given that the odds of choosing the same 48-bit random number is about 1 in 281 trillion. Normally people use 64-bit random numbers for global uniqueness, but we don't need global uniqueness, just unique for the given author at that precise millisecond in time. These addresses sort in chronological order, per author.","title":"Address Reference"},{"location":"reply_comment/","text":"Reply Comment PAGE STATUS: incomplete Kind = 0x5 - Reply Comment Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral. Tags This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3.","title":"Reply Comment"},{"location":"reply_comment/#reply-comment","text":"PAGE STATUS: incomplete Kind = 0x5 - Reply Comment","title":"Reply Comment"},{"location":"reply_comment/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"reply_comment/#tags","text":"This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3.","title":"Tags"},{"location":"rest/","text":"Mosaic over REST PAGE STATUS: TBD Unlike WebSockets (and WebTransport), servers cannot notify clients of new records over REST. Clients must instead poll.","title":"REST"},{"location":"rest/#mosaic-over-rest","text":"PAGE STATUS: TBD Unlike WebSockets (and WebTransport), servers cannot notify clients of new records over REST. Clients must instead poll.","title":"Mosaic over REST"},{"location":"status/","text":"Status and Development Page statuses Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented in core Implemented in core + xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status. Versions and Attribution Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Steve Farroll edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible. Principles of Design The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media ones. The protocol should not impede high-performance high-throughput implementations. It is okay to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are optional. For example, we can have multiple transports (WebSockets, WebTransport, even REST) without all the developers needing to move beyond WebSockets. Everybody must implement the entire core plus WebSockets transport. Code that isn't required by everybody should be defined outside of core as an extension, transport, or application, as these are all optional. Core Library This specification is being developed in parallel to a core library . The findings from development feed back into this specification.","title":"Status and Development"},{"location":"status/#status-and-development","text":"","title":"Status and Development"},{"location":"status/#page-statuses","text":"Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented in core Implemented in core + xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status.","title":"Page statuses"},{"location":"status/#versions-and-attribution","text":"Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Steve Farroll edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible.","title":"Versions and Attribution"},{"location":"status/#principles-of-design","text":"The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media ones. The protocol should not impede high-performance high-throughput implementations. It is okay to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are optional. For example, we can have multiple transports (WebSockets, WebTransport, even REST) without all the developers needing to move beyond WebSockets. Everybody must implement the entire core plus WebSockets transport. Code that isn't required by everybody should be defined outside of core as an extension, transport, or application, as these are all optional.","title":"Principles of Design"},{"location":"status/#core-library","text":"This specification is being developed in parallel to a core library . The findings from development feed back into this specification.","title":"Core Library"},{"location":"sync_protocol_extension/","text":"Mosaic Sync Protocol Extension PAGE STATUS: incomplete This extends the protocol with negentropy support. The following messages are added: Client messages Sync Init 0x10 This is the initialization of a negentropy sync of records Sync Data 0x11 This is a data packet within a negentropy sync of records Sync Close 0x12 This is the closing of a negentropy sync of records Server messages Sync Data 0x91 This is a data packet within a negentropy sync of records Sync Error 0x93 This is an indication that negentropy sync has failed","title":"Sync Protocol Extension"},{"location":"sync_protocol_extension/#mosaic-sync-protocol-extension","text":"PAGE STATUS: incomplete This extends the protocol with negentropy support. The following messages are added:","title":"Mosaic Sync Protocol Extension"},{"location":"sync_protocol_extension/#client-messages","text":"","title":"Client messages"},{"location":"sync_protocol_extension/#sync-init","text":"0x10 This is the initialization of a negentropy sync of records","title":"Sync Init"},{"location":"sync_protocol_extension/#sync-data","text":"0x11 This is a data packet within a negentropy sync of records","title":"Sync Data"},{"location":"sync_protocol_extension/#sync-close","text":"0x12 This is the closing of a negentropy sync of records","title":"Sync Close"},{"location":"sync_protocol_extension/#server-messages","text":"","title":"Server messages"},{"location":"sync_protocol_extension/#sync-data_1","text":"0x91 This is a data packet within a negentropy sync of records","title":"Sync Data"},{"location":"sync_protocol_extension/#sync-error","text":"0x93 This is an indication that negentropy sync has failed","title":"Sync Error"},{"location":"tag_types/","text":"Tag types PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format. Public Key (0x1) Type = 0x1 Value = A public key This tag indicates that the record is of interest to the person identified by the public key. By being tagged as such, that person can easily look up such records. Note that such records should be delivered to all of this persons' INBOX servers as specified in their bootstrap record. Reply, Hash Reference (0x2) Type = 0x2 Value = A 32-byte hash reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Hash Reference 0x4 tag as well. Reply, Address Reference (0x3) Type = 0x3 Value = A 48-byte address reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Address Reference 0x5 tag as well. Root, Hash Reference (0x4) Type = 0x4 Value = A 32-byte hash reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Hash Reference 0x2 tag as well. Root, Address Reference (0x5) Type = 0x5 Value = A 48-byte address reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Address Reference 0x3 tag as well. Quote, Hash Reference (0x6) Type = 0x6 Value = A 32-byte hash reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted. Quote, Address Reference (0x7) Type = 0x7 Value = A 48-byte address reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted.","title":"Tag Types"},{"location":"tag_types/#tag-types","text":"PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format.","title":"Tag types"},{"location":"tag_types/#public-key-0x1","text":"Type = 0x1 Value = A public key This tag indicates that the record is of interest to the person identified by the public key. By being tagged as such, that person can easily look up such records. Note that such records should be delivered to all of this persons' INBOX servers as specified in their bootstrap record.","title":"Public Key (0x1)"},{"location":"tag_types/#reply-hash-reference-0x2","text":"Type = 0x2 Value = A 32-byte hash reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Hash Reference 0x4 tag as well.","title":"Reply, Hash Reference (0x2)"},{"location":"tag_types/#reply-address-reference-0x3","text":"Type = 0x3 Value = A 48-byte address reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Address Reference 0x5 tag as well.","title":"Reply, Address Reference (0x3)"},{"location":"tag_types/#root-hash-reference-0x4","text":"Type = 0x4 Value = A 32-byte hash reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Hash Reference 0x2 tag as well.","title":"Root, Hash Reference (0x4)"},{"location":"tag_types/#root-address-reference-0x5","text":"Type = 0x5 Value = A 48-byte address reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Address Reference 0x3 tag as well.","title":"Root, Address Reference (0x5)"},{"location":"tag_types/#quote-hash-reference-0x6","text":"Type = 0x6 Value = A 32-byte hash reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted.","title":"Quote, Hash Reference (0x6)"},{"location":"tag_types/#quote-address-reference-0x7","text":"Type = 0x7 Value = A 48-byte address reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted.","title":"Quote, Address Reference (0x7)"},{"location":"timestamps/","text":"Timestamps PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds, and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0. Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds, unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Rationale: UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). The first bit is zero in case it is ever interpreted as a sign bit, in order to preserve sorting. Millisecond unixtimes in 47 bits give us more than 4000 years before they roll over. Refer to the IANA leap second list","title":"Timestamps"},{"location":"timestamps/#timestamps","text":"PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds, and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0. Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds, unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Rationale: UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). The first bit is zero in case it is ever interpreted as a sign bit, in order to preserve sorting. Millisecond unixtimes in 47 bits give us more than 4000 years before they roll over. Refer to the IANA leap second list","title":"Timestamps"},{"location":"websockets/","text":"Mosaic over Websockets PAGE STATUS: Draft TLS Over WebSockets, Mosaic must use TLS version at least 1.2, preferably TLS 1.3 . TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. TLS certificates shall be either RawPublicKey or self-signed, and use the ed25519 public key (either the server's master public key or the client's signing public key). Servers SHOULD request client-side certificates if they wish to authenticate users. If clients do not provide certificates, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not. WebSockets Mosaic messages are transported over WebSockets Sec-WebSocket-Protocol Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Servers MUST reply with the protocol they have accepted in the same header, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols. X-Mosaic-Extensions Clients MAY present an X-Mosiac-Extensions header to specify the extentions they support and may wish to use. The value of an X-Mosiac-Extensions header is a list of extension names separated by semicolons. Clients SHOULD NOT present an X-Mosaic-Extensions header in the handshake unless they are not requesting any extensions. The following extension names are defined: SYNC Servers MUST check for an X-Mosaic-Extensions header. If one is specified, split it's contents on semicolons. Remove all extensions you are unable to service. Join these back together and return an X-Mosaic-Extensions header with this string. If that string was empty, use a - instead. Clients MUST check for an X-Mosaic-Extensions header during negotiation, and configure themselves to use only the extensions that the server returned to them, considering - as the empty set. X-Mosaic-Service-Url Servers MAY present a service URL for a website which users can visit in order to manage their relationship with the server (e.g. sign up for an account, make payment, view logs, or anything else that is relevant to that relationship). These kinds of activities are not standardized here. Binary All messages use websockets binary. Messages are formed as the binary message protocol specified in protocol . Each message starts with a single byte indicating the type, followed by the data that such type requires. Clients MUST only send client messages. If a server reads a server message from a client, it SHOULD disconnect. Servers MUST only send server messages. If a client reads a client message from a server, it SHOULD disconnect.","title":"WebSockets"},{"location":"websockets/#mosaic-over-websockets","text":"PAGE STATUS: Draft","title":"Mosaic over Websockets"},{"location":"websockets/#tls","text":"Over WebSockets, Mosaic must use TLS version at least 1.2, preferably TLS 1.3 . TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. TLS certificates shall be either RawPublicKey or self-signed, and use the ed25519 public key (either the server's master public key or the client's signing public key). Servers SHOULD request client-side certificates if they wish to authenticate users. If clients do not provide certificates, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not.","title":"TLS"},{"location":"websockets/#websockets","text":"Mosaic messages are transported over WebSockets","title":"WebSockets"},{"location":"websockets/#sec-websocket-protocol","text":"Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Servers MUST reply with the protocol they have accepted in the same header, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols.","title":"Sec-WebSocket-Protocol"},{"location":"websockets/#x-mosaic-extensions","text":"Clients MAY present an X-Mosiac-Extensions header to specify the extentions they support and may wish to use. The value of an X-Mosiac-Extensions header is a list of extension names separated by semicolons. Clients SHOULD NOT present an X-Mosaic-Extensions header in the handshake unless they are not requesting any extensions. The following extension names are defined: SYNC Servers MUST check for an X-Mosaic-Extensions header. If one is specified, split it's contents on semicolons. Remove all extensions you are unable to service. Join these back together and return an X-Mosaic-Extensions header with this string. If that string was empty, use a - instead. Clients MUST check for an X-Mosaic-Extensions header during negotiation, and configure themselves to use only the extensions that the server returned to them, considering - as the empty set.","title":"X-Mosaic-Extensions"},{"location":"websockets/#x-mosaic-service-url","text":"Servers MAY present a service URL for a website which users can visit in order to manage their relationship with the server (e.g. sign up for an account, make payment, view logs, or anything else that is relevant to that relationship). These kinds of activities are not standardized here.","title":"X-Mosaic-Service-Url"},{"location":"websockets/#binary","text":"All messages use websockets binary. Messages are formed as the binary message protocol specified in protocol . Each message starts with a single byte indicating the type, followed by the data that such type requires. Clients MUST only send client messages. If a server reads a server message from a client, it SHOULD disconnect. Servers MUST only send server messages. If a client reads a client message from a server, it SHOULD disconnect.","title":"Binary"},{"location":"webtransport/","text":"Mosaic over Webtransport PAGE STATUS: TBD Intend to specify a subprotocol in the websockets HTTP header","title":"WebTransport"},{"location":"webtransport/#mosaic-over-webtransport","text":"PAGE STATUS: TBD Intend to specify a subprotocol in the websockets HTTP header","title":"Mosaic over Webtransport"}]}