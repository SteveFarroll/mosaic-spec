{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mosaic PAGE STATUS: early draft Introduction Mosaic is a distributed sovereign general-purpose application protocol for the Internet. distributed : There is no central point of failure, or place that can be taken down. There is no central place to \"bootstrap\" Mosaic (other than Mainline DHT's bootstrapping). sovereign : All nodes (users/clients and servers) participation is self-managed and nobody can cancel your account. You manage your own keys. Mosaic does not depend on DNS and Mosaic does not depend on Certification Authorities to issue certificates. general-purpose : Although it started as social media, this architecture has been shown to serve many general-purpose applications. Mosaic is a work in progress . This specification is EARLY DRAFT. What Mosaic is not Mosaic is NOT peer-to-peer : Around the turn of the century, a lot of distributed sovereign protocol work focused on peer-to-peer: Freenet, GnuNET, and later DHTs. As it turns out, peer-to-peer is difficult because most computers are not fully connected to the Internet. And as there is nothing particular difficult in running a server that is fully connected to the Internet (given VPS availability), being strictly peer-to-peer doesn't seem advantageous. So we choose the more rock-solid client-server architecture. Mosaic does NOT provide IP privacy : Around the turn of the century, a lot of distributed sovereign protocol work focused on IP privacy: Freenet, GnuNET, etc. However, Tor took off as a general privacy layer, and other alternatives exist including i2p and VPNs. Architecturally, it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer since Mosaic can run on top of an already existing privacy layer. Where Mosaic came from Mosaic is an offshoot of nostr . Like nostr: Mosaic uses sovereign user-controlled key pairs Mosaic uses WebSockets Mosaic uses client-server architecture, since peer-to-peer has connectivity problems Mosaic doesn't provide IP privacy Unlike nostr: Mosaic uses different cryptography (EdDSA ed25519 and BLAKE3) Mosaic uses subkeys from the start for better key management Mosaic servers have keypair-based identities too, so you can be sure that you are connecting to the right server. Servers are identified by the public key, not their DNS-based URL. Mosaic information (server's IP addresses and user's home server information) is bootstrapped from Mainline DHT Mosaic records are binary. The minimal Mosaic record is 216 bytes, versus the minimal nostr record of 343 byes. The overhead of JSON parsing along with it's ambiguity is gone! Simple tools and library functions can easily convert to/from JSON or indeed any other way you wish to see the data. Mosaic records are editable if an application wants them to be, as all records can be addressed either by their hash (not replaceable) or their address (replaceable) and all records have both a hash and an address. Mosaic WebSockets uses TLS 1.2 or 1.3 with either self-signed certificates or RawPublicKey, so that no dependency is made upon self-proclaimed certificate authority companies. Client authentication by servers is done at the TLS layer where clients also present self-signed or RawPublicKey certificates. Timestamps account for leap seconds (unlike unixtime) and have millisecond accuracy. Clients and Servers remember the time that records are received, so that key revocation can revoke all records received after a certain time, and not rely on the possibly fake timestamps in the records themselves. The specification is layered, and focused on the core. Applications using Mosaic are to be specified in their own respective places. Terminology differences Nostr events are called records Nostr event IDs are called record hashes Nostr relays are called servers The name Mosaic No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"Mosaic Introduction"},{"location":"#mosaic","text":"PAGE STATUS: early draft","title":"Mosaic"},{"location":"#introduction","text":"Mosaic is a distributed sovereign general-purpose application protocol for the Internet. distributed : There is no central point of failure, or place that can be taken down. There is no central place to \"bootstrap\" Mosaic (other than Mainline DHT's bootstrapping). sovereign : All nodes (users/clients and servers) participation is self-managed and nobody can cancel your account. You manage your own keys. Mosaic does not depend on DNS and Mosaic does not depend on Certification Authorities to issue certificates. general-purpose : Although it started as social media, this architecture has been shown to serve many general-purpose applications. Mosaic is a work in progress . This specification is EARLY DRAFT.","title":"Introduction"},{"location":"#what-mosaic-is-not","text":"Mosaic is NOT peer-to-peer : Around the turn of the century, a lot of distributed sovereign protocol work focused on peer-to-peer: Freenet, GnuNET, and later DHTs. As it turns out, peer-to-peer is difficult because most computers are not fully connected to the Internet. And as there is nothing particular difficult in running a server that is fully connected to the Internet (given VPS availability), being strictly peer-to-peer doesn't seem advantageous. So we choose the more rock-solid client-server architecture. Mosaic does NOT provide IP privacy : Around the turn of the century, a lot of distributed sovereign protocol work focused on IP privacy: Freenet, GnuNET, etc. However, Tor took off as a general privacy layer, and other alternatives exist including i2p and VPNs. Architecturally, it makes sense to separate application layers from privacy layers. There is no good reason to reinvent another privacy layer since Mosaic can run on top of an already existing privacy layer.","title":"What Mosaic is not"},{"location":"#where-mosaic-came-from","text":"Mosaic is an offshoot of nostr . Like nostr: Mosaic uses sovereign user-controlled key pairs Mosaic uses WebSockets Mosaic uses client-server architecture, since peer-to-peer has connectivity problems Mosaic doesn't provide IP privacy Unlike nostr: Mosaic uses different cryptography (EdDSA ed25519 and BLAKE3) Mosaic uses subkeys from the start for better key management Mosaic servers have keypair-based identities too, so you can be sure that you are connecting to the right server. Servers are identified by the public key, not their DNS-based URL. Mosaic information (server's IP addresses and user's home server information) is bootstrapped from Mainline DHT Mosaic records are binary. The minimal Mosaic record is 216 bytes, versus the minimal nostr record of 343 byes. The overhead of JSON parsing along with it's ambiguity is gone! Simple tools and library functions can easily convert to/from JSON or indeed any other way you wish to see the data. Mosaic records are editable if an application wants them to be, as all records can be addressed either by their hash (not replaceable) or their address (replaceable) and all records have both a hash and an address. Mosaic WebSockets uses TLS 1.2 or 1.3 with either self-signed certificates or RawPublicKey, so that no dependency is made upon self-proclaimed certificate authority companies. Client authentication by servers is done at the TLS layer where clients also present self-signed or RawPublicKey certificates. Timestamps account for leap seconds (unlike unixtime) and have millisecond accuracy. Clients and Servers remember the time that records are received, so that key revocation can revoke all records received after a certain time, and not rely on the possibly fake timestamps in the records themselves. The specification is layered, and focused on the core. Applications using Mosaic are to be specified in their own respective places. Terminology differences Nostr events are called records Nostr event IDs are called record hashes Nostr relays are called servers","title":"Where Mosaic came from"},{"location":"#the-name-mosaic","text":"No reason. Just a name. Easy to remember and pronounce. A throwback to the old NCSA Mosaic browser I suppose. It is not an acronym. We always capitalize it even in the middle of a sentence.","title":"The name Mosaic"},{"location":"appids/","text":"Application IDs PAGE STATUS: Early Draft Application IDs are 4-byte unsigned integers in little-endian format. Core 0x1 - Key Schedule 0x2 - Profile Social Media 0x3 - Microblog Root 0x4 - Reply Comment 0x5 - Blog post 0x6 - Chat message","title":"Application IDs"},{"location":"appids/#application-ids","text":"PAGE STATUS: Early Draft Application IDs are 4-byte unsigned integers in little-endian format.","title":"Application IDs"},{"location":"appids/#core","text":"0x1 - Key Schedule 0x2 - Profile","title":"Core"},{"location":"appids/#social-media","text":"0x3 - Microblog Root 0x4 - Reply Comment 0x5 - Blog post 0x6 - Chat message","title":"Social Media"},{"location":"blog/","text":"Blog PAGE STATUS: early draft App ID = 0x6 - Blog post Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral. Tags Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7.","title":"Blog"},{"location":"blog/#blog","text":"PAGE STATUS: early draft App ID = 0x6 - Blog post","title":"Blog"},{"location":"blog/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Blogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Blogs are not ephemeral.","title":"Flags"},{"location":"blog/#tags","text":"Blogs SHOULD not have the following tags: 0x1, 0x2, 0x3, 0x4, 0x5, 0x6. Blogs MAY have 0x7.","title":"Tags"},{"location":"bootstrap/","text":"Bootstrap PAGE STATUS: draft When you first find out about a new public key, you may already know if it represents a user or a server (by the context) or you may not even know that. And you also may not know what servers this key uses to host it's key schedule , and profile information, or to publish it's records or receive messages. We store bootstrap records in Mainline DHT. Mainline DHT We use Mainline DHT to store mutable data signed under an ed25519 signature according to BEP 0044 . Rationale: Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It also has this mutable data functionality and works with ed25519 signed data. Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours. Salt We use a salt of \"msb24\" for server bootstrap records and \"mub24\" for user bootstrap records. Rationale: We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap record in the future, and because we have two different kinds of bootstrap records already (this allows a server keypair to also be a user keypair without collision). This salts are short enough to not use too much space. Sequence Numbers Sequence numbers should start at 1 and monotonically increase with each write. Rust code A rust library to access this: https://github.com/pubky/mainline Bootstrap Record Format Bootstrap records (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character (0x0A, \\n). Lines MUST not have trailing whitespace. Two kinds of records may be stored, based on whether the identity represents a server or a user. Server Bootstrap Records Server bootstrap records specify the internet locations (protocol, host and port) that the server is available at. A server bootstrap record starts with the line S . Each subsequent line in a server bootstrap record specifies a URL where the server can be accessed. There can be any number of lines. However, the total length of the data cannot exceed 983 bytes. URLs must contain scheme and host, and may optionally contain a port. URLs must NOT contain user, password, path, query, or fragment sections. If any of those is found in a URL, software MUST prune such information. This includes pruning trailing slashes (which are paths). Only secure transports with TLS are defined. TLS must be version 1.2 or 1.3. The only known schemes currently are wss and https . Here are some examples of server bootstrap record lines: wss://203.0.113.1 specifies WebSockets with TLS on port 80 at IP address 203.0.113.0 . wss://203.0.113.0:5198 specifies WebSockets with TLS on port 5198 at IP address 203.0.113.0 . wss://myserverlk23lkjsefo8u.onion specifies WebSockets with TLS on port 443 over Tor. wss://[2001::130F::09C0:876A:130B] specifies WebSockets with TLS over IPv6 on port 443. https://mosaic.example:555 specifies WebTransport with TLS on port 555 to DNS node mosaic.example (https is to be interpreted as WebTransport, not REST). Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same records as the user bootstrap records. User Bootstrap Records User bootstrap records specify servers that the user uses, and how the user uses them. A user bootstrap record starts with the line U . Each line consists of two parts Server Usage Character This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. Bootstrap records such as the key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits. Server Key The second part is the server's public key, encoded using base64 (using the standard alphabet of RFC 4648). This will be 44 characters long ending in an = symbol. Example Here is an example user bootstrap record: U 1FB42YsY/CV2FqlMrI4CNeaZ2LnCHXzXmmdGKA+UsuBc= 3GQ859t+vK9gfYolOMfGB0VD/+kjk3iGFjxHj0GfhMos= 2L+RDYOrIKID+eEK81510TJ1pQOQW7kMrA10MwKOu0Iw= 3uBpfOVe3ooWMnc1RdMbYKBAIcHlfl2FsQU67lK2CJ8A= 6VKLdex3KykACzM0JpRfduelqwytel1AZGaXuv4sZhfU= Based on size limits of 983 bytes, no more than 20 records can be stored (but see below for other limitations on the number of servers). Should servers become unreliable, users can change servers and update these records at any time. Usage of servers and limits on their number Maximums : Users SHOULD list no more than 4 redundant servers of any kind, since more redundancy provides strongly dimishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first four servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Bootstrap"},{"location":"bootstrap/#bootstrap","text":"PAGE STATUS: draft When you first find out about a new public key, you may already know if it represents a user or a server (by the context) or you may not even know that. And you also may not know what servers this key uses to host it's key schedule , and profile information, or to publish it's records or receive messages. We store bootstrap records in Mainline DHT.","title":"Bootstrap"},{"location":"bootstrap/#mainline-dht","text":"We use Mainline DHT to store mutable data signed under an ed25519 signature according to BEP 0044 . Rationale: Mainline DHT is distributed and censorship resistant, including being resistant to (or able to detect) Sybil attacks. It also has this mutable data functionality and works with ed25519 signed data. Limitations: Only 1000 bytes can be reliably stored, and some will be used for bencoding overhead and the salt, leaving us only 983 bytes of usable data. Data must be refreshed periodically otherwise it may be removed after a time. Users are responsible for refreshing data in the Mainline DHT which will disappear over time. Mechanisms for this are out of scope for Mosaic Core. Data storage and retrieval may take a few seconds, and should not be done too frequently. Software SHOULD cache results for at least 2 hours.","title":"Mainline DHT"},{"location":"bootstrap/#salt","text":"We use a salt of \"msb24\" for server bootstrap records and \"mub24\" for user bootstrap records. Rationale: We use the salt to avoid collisions, in case the same ed25519 identity keypair is used by both mosaic and pubky , or in case we need to change the format of the bootstrap record in the future, and because we have two different kinds of bootstrap records already (this allows a server keypair to also be a user keypair without collision). This salts are short enough to not use too much space.","title":"Salt"},{"location":"bootstrap/#sequence-numbers","text":"Sequence numbers should start at 1 and monotonically increase with each write.","title":"Sequence Numbers"},{"location":"bootstrap/#rust-code","text":"A rust library to access this: https://github.com/pubky/mainline","title":"Rust code"},{"location":"bootstrap/#bootstrap-record-format","text":"Bootstrap records (the data after the bencoded prefix) are UTF-8 valid text up to 983 bytes long, and consist of a series of lines separated with a single ASCII Line Feed (LF) character (0x0A, \\n). Lines MUST not have trailing whitespace. Two kinds of records may be stored, based on whether the identity represents a server or a user.","title":"Bootstrap Record Format"},{"location":"bootstrap/#server-bootstrap-records","text":"Server bootstrap records specify the internet locations (protocol, host and port) that the server is available at. A server bootstrap record starts with the line S . Each subsequent line in a server bootstrap record specifies a URL where the server can be accessed. There can be any number of lines. However, the total length of the data cannot exceed 983 bytes. URLs must contain scheme and host, and may optionally contain a port. URLs must NOT contain user, password, path, query, or fragment sections. If any of those is found in a URL, software MUST prune such information. This includes pruning trailing slashes (which are paths). Only secure transports with TLS are defined. TLS must be version 1.2 or 1.3. The only known schemes currently are wss and https . Here are some examples of server bootstrap record lines: wss://203.0.113.1 specifies WebSockets with TLS on port 80 at IP address 203.0.113.0 . wss://203.0.113.0:5198 specifies WebSockets with TLS on port 5198 at IP address 203.0.113.0 . wss://myserverlk23lkjsefo8u.onion specifies WebSockets with TLS on port 443 over Tor. wss://[2001::130F::09C0:876A:130B] specifies WebSockets with TLS over IPv6 on port 443. https://mosaic.example:555 specifies WebTransport with TLS on port 555 to DNS node mosaic.example (https is to be interpreted as WebTransport, not REST). Servers are expected to operate as their own inbox/outbox and encryption server. So they do not require the same records as the user bootstrap records.","title":"Server Bootstrap Records"},{"location":"bootstrap/#user-bootstrap-records","text":"User bootstrap records specify servers that the user uses, and how the user uses them. A user bootstrap record starts with the line U . Each line consists of two parts","title":"User Bootstrap Records"},{"location":"bootstrap/#server-usage-character","text":"This first part is a single character that encodes that kind of usage. There are three defined server usages: Outbox - Outbox servers are where users publish public records meant to be read by anyone who is following the person's public content. Bootstrap records such as the key schedule and profile are published here. Inbox - Inbox servers are where users receive records that reference them, and where other users can follow replies to messages created by them. Encryption - Encryption servers function like an inbox but handle private encrypted messages (defined outside of Mosaic core) that only the user can read back. Outbox is indicated by bit 0 ( 1<<0 ) in the character. A 1 bit means the server is an outbox server. Inbox is indicated by bit 1 ( 1<<1 ) in the character. A 1 bit means the server is an inbox server. Encryption is indicated by bit 2 ( 1<<2 ) in the character. A 1 bit means the server is an encryption server. Bits 5 and 6 are always on. This is an ASCII '0' (48, 0x30). However a 0 should never be used as a server usage character as this would indicate no server usages, which is invalid as such a line should not exist. For example, to indicate only outbox usage, use character 1 . To indicate all three usages, use 7 . Conveniently with this encoding the ASCII number also matches the relavant bits.","title":"Server Usage Character"},{"location":"bootstrap/#server-key","text":"The second part is the server's public key, encoded using base64 (using the standard alphabet of RFC 4648). This will be 44 characters long ending in an = symbol.","title":"Server Key"},{"location":"bootstrap/#example","text":"Here is an example user bootstrap record: U 1FB42YsY/CV2FqlMrI4CNeaZ2LnCHXzXmmdGKA+UsuBc= 3GQ859t+vK9gfYolOMfGB0VD/+kjk3iGFjxHj0GfhMos= 2L+RDYOrIKID+eEK81510TJ1pQOQW7kMrA10MwKOu0Iw= 3uBpfOVe3ooWMnc1RdMbYKBAIcHlfl2FsQU67lK2CJ8A= 6VKLdex3KykACzM0JpRfduelqwytel1AZGaXuv4sZhfU= Based on size limits of 983 bytes, no more than 20 records can be stored (but see below for other limitations on the number of servers). Should servers become unreliable, users can change servers and update these records at any time.","title":"Example"},{"location":"bootstrap/#usage-of-servers-and-limits-on-their-number","text":"Maximums : Users SHOULD list no more than 4 redundant servers of any kind, since more redundancy provides strongly dimishing benefit at a linearly increasing network traffic cost. Software MUST utilize the first four servers of the appropriate kind listed, and MAY tolerate additional servers but optionally MAY ignore additional servers. Minimums : Users SHOULD have at least one outbox and at least one inbox. Users MAY have no encryption servers but they will not be able to receive encrypted messages.","title":"Usage of servers and limits on their number"},{"location":"chat/","text":"Chat PAGE STATUS: early draft App ID = 0x7 - chat message Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on Tags This MAY include up to one refer tag, either 0x6 or 0x7.","title":"Chat"},{"location":"chat/#chat","text":"PAGE STATUS: early draft App ID = 0x7 - chat message","title":"Chat"},{"location":"chat/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off 0x04 TORECIPIENTS - may be on or off 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- SHOULD be on","title":"Flags"},{"location":"chat/#tags","text":"This MAY include up to one refer tag, either 0x6 or 0x7.","title":"Tags"},{"location":"cryptography/","text":"Cryptography PAGE STATUS: early draft Hashing We use BLAKE3 in unkeyed hashing mode, producing a 512-bit digest. Rationale: This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and is about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. Yes 512-bits is a lot. But EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes anyways. We can always refer to events with a hash prefix. Alternative: Use the 512-bits in EdDSA ed25519, but only store the 256-bit prefix of that hash (BLAKE3 hashes are variable size, and smaller hashes are prefixes of larger hashes). Digital Signature We use EdDSA with the ed25519 curve and very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1. Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Rationale: Fast and space efficient Widely studied Very good resistance to side-channel attacks Does not require point validation In our form, provides the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature Interoperates with TLS, Mainline DHT, and other modern ed25519-based identity systems See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice Encryption Records in Mosaic are generally not encrypted, but public things. However some applications have a need to encrypt data. This is a general specification of how encryption is done. Encryption details are still TBD but we intend: To use ECIES To do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. We recommend using an encryption-only subkey pair for this purpose, which is not used in ed25519 signing. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Cryptography"},{"location":"cryptography/#cryptography","text":"PAGE STATUS: early draft","title":"Cryptography"},{"location":"cryptography/#hashing","text":"We use BLAKE3 in unkeyed hashing mode, producing a 512-bit digest. Rationale: This is a very fast hash function with 128-bit security. It is even sometimes faster in software than hardware versions of SHA-256, and is about 14x as fast as software versions of SHA-256. It is highly parallelizable and can take advantage of vector instructions. It's predecessor BLAKE was the most analyzed algorithm during the NIST SHA-3 competition. Yes 512-bits is a lot. But EdDSA ed25519 is defined to use SHA-512 and we are using BLAKE3 as a drop-in replacement, so we have to produce 512-bit hashes anyways. We can always refer to events with a hash prefix. Alternative: Use the 512-bits in EdDSA ed25519, but only store the 256-bit prefix of that hash (BLAKE3 hashes are variable size, and smaller hashes are prefixes of larger hashes).","title":"Hashing"},{"location":"cryptography/#digital-signature","text":"We use EdDSA with the ed25519 curve and very specific public key and signature validation checks. In particular: Public keys should be rejected if they are one of 8 small order points. Signatures must be rejected if s is not within the range 0..L-1. Signatures must be rejected if R or A are non-canonical (e.g. verify that |R| >= L and |A| >= L) Always use cofactor verification (8(S \u00b7 B) \u2212 8R \u2212 8(h \u00b7 A) = 0) not the non-cofactor one, even when not in batch mode. Rationale: Fast and space efficient Widely studied Very good resistance to side-channel attacks Does not require point validation In our form, provides the following guarantees: Existentially and Strongly unforgeable under chosen message attacks Strongly Binding Signature Interoperates with TLS, Mainline DHT, and other modern ed25519-based identity systems See Taming the many EdDSAs See The Provable Security of Ed25519: Theory and Practice","title":"Digital Signature"},{"location":"cryptography/#encryption","text":"Records in Mosaic are generally not encrypted, but public things. However some applications have a need to encrypt data. This is a general specification of how encryption is done. Encryption details are still TBD but we intend: To use ECIES To do the diffie-hellman between an ephemeral keypair generated by the sender and used only once, and one of the recipient's x25519 public keys (published in their key schedule), which is not ephemeral but may nonetheless be frequently rolled over by the recipient. In order for a user to decrypt on any of their devices, they must share the x25519 public key's secret to all of their devices. We recommend using an encryption-only subkey pair for this purpose, which is not used in ed25519 signing. See keyschedule marker 0x2. See also this page at cryptosys.net","title":"Encryption"},{"location":"identity/","text":"Identity PAGE STATUS: early draft Users and Servers Identities are split between Users and Servers. Users in Mosaic are self-created and self-administered. This puts each user in control of their own account, allowing them to digitally sign their content, move to different servers and not to rely on any central service or authority. This however also requires each end user to securely manage their private key material. Convenient methods for doing so, as well as recovery, are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or perhaps managed by a trusted service. Public key cryptosystem keypair Identities are realized as a keypair produced within a public key cryptosystem. We use the EdDSA ed25519 cryptosystem for digital signature. See cryptography . A user is identified by their ed25519 master public key. Master keys and Subkeys Users may have subsidiary public keys, known as subkeys . At times this may also be called signing keys or device keys . The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or nostr secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing or modifying a user's key schedule with new keys and/or revocations. Publishing or modifying a user's server list Publishing or modifying a user's profile record Subkeys might be deterministically derived from the master private key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Identity"},{"location":"identity/#identity","text":"PAGE STATUS: early draft","title":"Identity"},{"location":"identity/#users-and-servers","text":"Identities are split between Users and Servers. Users in Mosaic are self-created and self-administered. This puts each user in control of their own account, allowing them to digitally sign their content, move to different servers and not to rely on any central service or authority. This however also requires each end user to securely manage their private key material. Convenient methods for doing so, as well as recovery, are outside of the scope of Mosaic except insomuch as we define master keys and subkeys with the purpose that subkeys are intended for online use, and master keys are intended to be long-term and kept more securely, perhaps being offline, in hardware, or perhaps managed by a trusted service.","title":"Users and Servers"},{"location":"identity/#public-key-cryptosystem-keypair","text":"Identities are realized as a keypair produced within a public key cryptosystem. We use the EdDSA ed25519 cryptosystem for digital signature. See cryptography . A user is identified by their ed25519 master public key.","title":"Public key cryptosystem keypair"},{"location":"identity/#master-keys-and-subkeys","text":"Users may have subsidiary public keys, known as subkeys . At times this may also be called signing keys or device keys . The purpose of subkeys is for online usage in less secure environments, where compromise and revocation do not invalidate the master key identity that the user is known by. Subkeys also support alternative algorithms, such as X25519 public keys for receiving encrypted information, or nostr secp256k1 keys for backwards compatibility with nostr. Users publish their subkeys in a key schedule record , defined within the core records specification. A limited number of low-frequency operations in Mosaic require a signature from the master key. These include (presently): Publishing or modifying a user's key schedule with new keys and/or revocations. Publishing or modifying a user's server list Publishing or modifying a user's profile record Subkeys might be deterministically derived from the master private key, or they might not. Nothing in the Mosaic spec requires such, but some implementations may make use of this.","title":"Master keys and Subkeys"},{"location":"keyschedule/","text":"Key Schedule Record PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has Application ID 0x1. A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical. Tags Every subkey listed in a key schedule record must have an associated Subkey tag listing the subkey. Payload `The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Subkey 1/4 | 8 +-------------------------------+ | Subkey 2/4 | 16 +-------------------------------+ | Subkey 3/4 | 24 +-------------------------------+ | Subkey 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ Marker [32:33] is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. Res [33:34] is 1-byte and is reserved. It MUST be 0. Timestamp [34:40] is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases.","title":"Key Schedule"},{"location":"keyschedule/#key-schedule-record","text":"PAGE STATUS: early draft A key schedule record lists subkey information and revocation information for a master key. A key schedule record has Application ID 0x1. A key schedule record MUST be considered invalid if it does not conform to this specification. A key schedule record MUST be considered invalid if the signing key and the master key are not identical.","title":"Key Schedule Record"},{"location":"keyschedule/#tags","text":"Every subkey listed in a key schedule record must have an associated Subkey tag listing the subkey.","title":"Tags"},{"location":"keyschedule/#payload","text":"`The payload contains a sequence of 40-byte subkey records laid out as follows: 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Subkey 1/4 | 8 +-------------------------------+ | Subkey 2/4 | 16 +-------------------------------+ | Subkey 3/4 | 24 +-------------------------------+ | Subkey 4/4 | 32 +-------------------------------+ |MARKER|RES|REVOC TIMESTAMP | +-------------------------------+ Marker [32:33] is 1-byte and is one of the following 0x0 - ACTIVE_SIGNING_KEY - A Mosaic ed25519 signing key (subkey) in current use 0x1 - ACTIVE_ENCRYPTION_KEY - A Mosaic X25519 encryption key in current use These keys are used for receiving encrypted data only, not for signing. Generally the secretkey for encryption is distributed to every device that needs the ability to view encrypted data. Being a separate subkey from the signing keys, it limits the damage from compromise. 0x40 - REVOKED_ALL - All records signed by the key are to be considered invalid. 0x41 - REVOKED_PAST - Records signed by the key that were received prior to the revocation timestamp (based on when it was received by software and NOT based on the date inside of the record) are still considered valid; however, records either received after the revocation timestamp, or with a timestamp after the revocation timestamp, are considered invalid. 0x4F - OUT_OF_USE - Key is no longer in use (but nothing is revoked). This may be used for signing keys or encryption keys. 0x80 - ACTIVE_NOSTR_KEY - A nostr secp256k1 subkey This helps support dual-stack software that works with both nostr and Mosaic. Res [33:34] is 1-byte and is reserved. It MUST be 0. Timestamp [34:40] is 6-bytes and is in the format described in timestamps . Timestamp is required for REVOKED ALL and REVOKED PAST. Timestamp is suggested for OUT_OF_USE. Timestamp SHOULD be zeroed in all other cases.","title":"Payload"},{"location":"microblog/","text":"Microblog PAGE STATUS: incomplete App ID = 0x4 - Root Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Microblogging"},{"location":"microblog/#microblog","text":"PAGE STATUS: incomplete App ID = 0x4 - Root","title":"Microblog"},{"location":"microblog/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - MUST be off. Microblogs are public. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"profile/","text":"Profile Record PAGE STATUS: TBD A profile record contains user profile information.","title":"Profile"},{"location":"profile/#profile-record","text":"PAGE STATUS: TBD A profile record contains user profile information.","title":"Profile Record"},{"location":"protocol/","text":"Protocol PAGE STATUS: incomplete TBD: Server-Client feature negotation, includes nonce. TBD: signed messages from client, as well as unsigned ones, rather than AUTH. Client messages 0x1 - Query This is a query for records. Includes an query id for matching up server replies. Includes a filter specifying which records are sought. Servers are expected to reply with: * 0x80 Record * 0x81 Query Complete * 0x82 Query Closed 0x2 - Close Query This is a request to close a query. Includes an identifier for matching up server replies. Servers are expected to reply with: * 0x82 Query Closed 0x3 - Submission This is the submission of a record. Includes the record submitted. Servers are expected to reply with: * 0x83 Submission Result 0x10 - Sync Init This is the initialization of a negentropy sync of records 0x11 - Sync Data This is a data packet within a negentropy sync of records 0x12 - Sync Close This is the closing of a negentropy sync of records Server messages 0x80 - Record This is a record. Includes a query id that the record came in on. 0x81 - Query Complete This indicates that a query is complete. This does not mean the query will close, as subsequently received records that match the query will be subsequently returned. Includes a query id that the record came in on. 0x82 - Query Closed This indicates that a query has been closed It must include a coded reason. 0x83 - Submission Result This returns the result of a submission. 0x91 - Sync Data This is a data packet within a negentropy sync of records 0x93 - Sync Error This is an indication that negentropy sync has failed","title":"Protocol"},{"location":"protocol/#protocol","text":"PAGE STATUS: incomplete TBD: Server-Client feature negotation, includes nonce. TBD: signed messages from client, as well as unsigned ones, rather than AUTH.","title":"Protocol"},{"location":"protocol/#client-messages","text":"","title":"Client messages"},{"location":"protocol/#0x1-query","text":"This is a query for records. Includes an query id for matching up server replies. Includes a filter specifying which records are sought. Servers are expected to reply with: * 0x80 Record * 0x81 Query Complete * 0x82 Query Closed","title":"0x1 - Query"},{"location":"protocol/#0x2-close-query","text":"This is a request to close a query. Includes an identifier for matching up server replies. Servers are expected to reply with: * 0x82 Query Closed","title":"0x2 - Close Query"},{"location":"protocol/#0x3-submission","text":"This is the submission of a record. Includes the record submitted. Servers are expected to reply with: * 0x83 Submission Result","title":"0x3 - Submission"},{"location":"protocol/#0x10-sync-init","text":"This is the initialization of a negentropy sync of records","title":"0x10 - Sync Init"},{"location":"protocol/#0x11-sync-data","text":"This is a data packet within a negentropy sync of records","title":"0x11 - Sync Data"},{"location":"protocol/#0x12-sync-close","text":"This is the closing of a negentropy sync of records","title":"0x12 - Sync Close"},{"location":"protocol/#server-messages","text":"","title":"Server messages"},{"location":"protocol/#0x80-record","text":"This is a record. Includes a query id that the record came in on.","title":"0x80 - Record"},{"location":"protocol/#0x81-query-complete","text":"This indicates that a query is complete. This does not mean the query will close, as subsequently received records that match the query will be subsequently returned. Includes a query id that the record came in on.","title":"0x81 - Query Complete"},{"location":"protocol/#0x82-query-closed","text":"This indicates that a query has been closed It must include a coded reason.","title":"0x82 - Query Closed"},{"location":"protocol/#0x83-submission-result","text":"This returns the result of a submission.","title":"0x83 - Submission Result"},{"location":"protocol/#0x91-sync-data","text":"This is a data packet within a negentropy sync of records","title":"0x91 - Sync Data"},{"location":"protocol/#0x93-sync-error","text":"This is an indication that negentropy sync has failed","title":"0x93 - Sync Error"},{"location":"record/","text":"Record PAGE STATUS: draft FIXME: The exact length of the tags and payload sections are not known, only to 8-bit word cutoff. We should add 6 bits to express the exact length of the data minus the padding... possibly at the reserved area... possibly swap that with flags. A record is a datum within Mosaic. All datums are records. Notation Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11. Maximum Size The maximum size of a record is 1 mebibyte (1,048,576 bytes). This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes. Layout Note that records are laid out in a way to provide 64-bit alignment. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | +-------------------------------+ | Signature 2/8 | +-------------------------------+ | Signature 3/8 | +-------------------------------+ | Signature 4/8 | +-------------------------------+ | Signature 5/8 | +-------------------------------+ | Signature 6/8 | +-------------------------------+ | Signature 7/8 | +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ | Hash 1/4 | +-------------------------------+ | Hash 2/4 | +-------------------------------+ | Hash 3/4 | +-------------------------------+ | Hash 4/4 | 96 +-------------------------------+ | Hash 1/4 | +-------------------------------+ | Hash 2/4 | +-------------------------------+ | Hash 3/4 | +-------------------------------+ | Hash 4/4 | 128 +-------------------------------+ | Signing public key, 1/4 | +-------------------------------+ | Signing public key, 2/4 | +-------------------------------+ | Signing public key, 3/4 | +-------------------------------+ | Signing public key, 4/4 | 160 +-------------------------------+ | Author public key, 1/4 | +-------------------------------+ | Author public key, 2/4 | +-------------------------------+ | Author public key, 3/4 | +-------------------------------+ | Author public key, 4/4 | 192 +-------------------------------+ | Timestamp | Nonce | 200 +-------------------------------+ | ... Nonce | Appl ID | 208 +-------------------------------+ | Len_t | Len_p |FLAGS |RESERVED| 216 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+ Fields Records contain the following fields. See the layout section for the binary layout of these fields within a record. Signature 64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature using the 64-byte hash at [64:128] . ph means \"pre hashed\" (we will hash the content with BLAKE3 and tell EdDSA that it is a SHA-512 hash of the message). We also provide a context to this algorithm of b\"Mosaic\"; This signature is made with the Signing private key and is represented in 64 bytes. Rationale: EdDSA uses a SHA-512 hashing internal to the algorithm. But BLAKE3 is a faster especially for longer messages, and EdDSA works just fine with it. We provide a context so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application). Hash 64 bytes at [64:128] The hashing function is BLAKE3, unkeyed. We use the finalize_xof() function to extend the output from the default 256-bits up to 512 bits. This input of the hash is all the data starting at byte 128, [128:] , everything except the signature and hash itself. Signing Public Key 32 bytes at [128:160] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). This is represented in 32 bytes (256 bits). Author Public Key 32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair, which is represented in 32 bytes (256 bits). Timestamp 6 bytes at [192:198] This is a timestamp represented in 6 bytes (48 bits) according to timestamps . Nonce 6 bytes at [198:204] This is represented in 6 bytes (48 bits). These are randomly generated (except in the case of record replacement, where they are copied from the prior record). The purpose of the nonce is to ensure that address-based references are unique. See References . Application ID 4 bytes at [204:208] This is the ID of the application this record services (like a nostr kind), represented in 4 bytes (32 bits) as an unsigned integer, little-endian. Len_t 2 bytes at [208:210] representing the length of the tags section divided by 8, as an unsigned integer in litte-endian format. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes. Len_p 2 bytes at [210:212] representing the length of the payload section divided by 8, as an unsigned integer in little-endian format. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes. Flags 2 bytes at [212:214] Reserved flags MUST be set to 0. 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED 0x40 - RESERVED 0x80 - RESERVED 0x100 - RESERVED 0x200 - RESERVED 0x400 - RESERVED 0x800 - RESERVED 0x1000 - RESERVED 0x2000 - RESERVED 0x4000 - RESERVED 0x8000 - RESERVED Reserved 2 bytes at [214:216] This Reserved space MUST be set to 0. Tags Varying bytes at [216:216+Len_t] These are searchable key-value tags. Unlike nostr tags, all of thsese are searchable. If an application requires unsearchable tags, these can be defined within that application's payload. Each tag has a 2 byte (16 bit) type and a value that is at most 253 bytes long. Tags are laid out as follows: +-------+---------+---------+ | type | length | value | +-------+---------+---------+ where the type is 2 bytes (16 bits) and the length is 1 byte (8 bits) and represents the length of the value, and the value is at most 253 bytes long. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes. Tag types are documented at Core tags RATIONALE: Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes, which may ease implementation in some cases. Payload Varying bytes at [216+Len_t:216+Len_t+Len_p]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes.","title":"Record"},{"location":"record/#record","text":"PAGE STATUS: draft FIXME: The exact length of the tags and payload sections are not known, only to 8-bit word cutoff. We should add 6 bits to express the exact length of the data minus the padding... possibly at the reserved area... possibly swap that with flags. A record is a datum within Mosaic. All datums are records.","title":"Record"},{"location":"record/#notation","text":"Byte slice notation [m:n] indicates the bytes including m up to and including the byte n-1 but not including the byte n . For example [8:12] represents bytes 8, 9, 10 and 11.","title":"Notation"},{"location":"record/#maximum-size","text":"The maximum size of a record is 1 mebibyte (1,048,576 bytes). This is specified so that length fields inside of records can be of a defined fixed number of bits and so that software can make reasonable decisions about buffer sizes.","title":"Maximum Size"},{"location":"record/#layout","text":"Note that records are laid out in a way to provide 64-bit alignment. 1 2 3 4 4 5 6 0 8 6 4 2 0 8 6 4 0 +-------------------------------+ | Signature 1/8 | +-------------------------------+ | Signature 2/8 | +-------------------------------+ | Signature 3/8 | +-------------------------------+ | Signature 4/8 | +-------------------------------+ | Signature 5/8 | +-------------------------------+ | Signature 6/8 | +-------------------------------+ | Signature 7/8 | +-------------------------------+ | Signature 8/8 | 64 +-------------------------------+ | Hash 1/4 | +-------------------------------+ | Hash 2/4 | +-------------------------------+ | Hash 3/4 | +-------------------------------+ | Hash 4/4 | 96 +-------------------------------+ | Hash 1/4 | +-------------------------------+ | Hash 2/4 | +-------------------------------+ | Hash 3/4 | +-------------------------------+ | Hash 4/4 | 128 +-------------------------------+ | Signing public key, 1/4 | +-------------------------------+ | Signing public key, 2/4 | +-------------------------------+ | Signing public key, 3/4 | +-------------------------------+ | Signing public key, 4/4 | 160 +-------------------------------+ | Author public key, 1/4 | +-------------------------------+ | Author public key, 2/4 | +-------------------------------+ | Author public key, 3/4 | +-------------------------------+ | Author public key, 4/4 | 192 +-------------------------------+ | Timestamp | Nonce | 200 +-------------------------------+ | ... Nonce | Appl ID | 208 +-------------------------------+ | Len_t | Len_p |FLAGS |RESERVED| 216 +-------------------------------+ | Tags... | | .. +PADDING | ? +-------------------------------+ | Payload ... | | .. +PADDING | ? +-------------------------------+","title":"Layout"},{"location":"record/#fields","text":"Records contain the following fields. See the layout section for the binary layout of these fields within a record.","title":"Fields"},{"location":"record/#signature","text":"64 bytes at [0:64] The signature field is the EdDSA ed25519ph signature using the 64-byte hash at [64:128] . ph means \"pre hashed\" (we will hash the content with BLAKE3 and tell EdDSA that it is a SHA-512 hash of the message). We also provide a context to this algorithm of b\"Mosaic\"; This signature is made with the Signing private key and is represented in 64 bytes. Rationale: EdDSA uses a SHA-512 hashing internal to the algorithm. But BLAKE3 is a faster especially for longer messages, and EdDSA works just fine with it. We provide a context so that users cannot be tricked by one application into signing content for a different application (in case users think they can use the same keypair for every application).","title":"Signature"},{"location":"record/#hash","text":"64 bytes at [64:128] The hashing function is BLAKE3, unkeyed. We use the finalize_xof() function to extend the output from the default 256-bits up to 512 bits. This input of the hash is all the data starting at byte 128, [128:] , everything except the signature and hash itself.","title":"Hash"},{"location":"record/#signing-public-key","text":"32 bytes at [128:160] This is the public key of the signing keypair, which is usually a subkey under the author's master keypair (but theoretically could be delegated in some other fashion in the future). This is represented in 32 bytes (256 bits).","title":"Signing Public Key"},{"location":"record/#author-public-key","text":"32 bytes at [160:192] This is the identity of the author, expressed as a public key from their master EdDSA ed25519 keypair, which is represented in 32 bytes (256 bits).","title":"Author Public Key"},{"location":"record/#timestamp","text":"6 bytes at [192:198] This is a timestamp represented in 6 bytes (48 bits) according to timestamps .","title":"Timestamp"},{"location":"record/#nonce","text":"6 bytes at [198:204] This is represented in 6 bytes (48 bits). These are randomly generated (except in the case of record replacement, where they are copied from the prior record). The purpose of the nonce is to ensure that address-based references are unique. See References .","title":"Nonce"},{"location":"record/#application-id","text":"4 bytes at [204:208] This is the ID of the application this record services (like a nostr kind), represented in 4 bytes (32 bits) as an unsigned integer, little-endian.","title":"Application ID"},{"location":"record/#len_t","text":"2 bytes at [208:210] representing the length of the tags section divided by 8, as an unsigned integer in litte-endian format. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes.","title":"Len_t"},{"location":"record/#len_p","text":"2 bytes at [210:212] representing the length of the payload section divided by 8, as an unsigned integer in little-endian format. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes.","title":"Len_p"},{"location":"record/#flags","text":"2 bytes at [212:214] Reserved flags MUST be set to 0. 0x01 ZSTD - The payload is compressed with Zstd 0x02 FROM_AUTHOR - Servers SHOULD only accept the record from the author (requiring authentication) 0x04 TO_RECIPIENTS - Servers SHOULD only serve the record to people tagged (requiring authentication) 0x08 NO_BRIDGE - Bridges SHOULD NOT propogate the record to other networks (nostr, mastodon, etc) 0x10 EPHEMERAL - The record is ephemeral; Servers should serve it to current subscribers and not keep it. 0x20 - RESERVED 0x40 - RESERVED 0x80 - RESERVED 0x100 - RESERVED 0x200 - RESERVED 0x400 - RESERVED 0x800 - RESERVED 0x1000 - RESERVED 0x2000 - RESERVED 0x4000 - RESERVED 0x8000 - RESERVED","title":"Flags"},{"location":"record/#reserved","text":"2 bytes at [214:216] This Reserved space MUST be set to 0.","title":"Reserved"},{"location":"record/#tags","text":"Varying bytes at [216:216+Len_t] These are searchable key-value tags. Unlike nostr tags, all of thsese are searchable. If an application requires unsearchable tags, these can be defined within that application's payload. Each tag has a 2 byte (16 bit) type and a value that is at most 253 bytes long. Tags are laid out as follows: +-------+---------+---------+ | type | length | value | +-------+---------+---------+ where the type is 2 bytes (16 bits) and the length is 1 byte (8 bits) and represents the length of the value, and the value is at most 253 bytes long. The tags section is padded out to 64-bit alignment. The maximum tags section length is 524288 bytes. Tag types are documented at Core tags RATIONALE: Tag values should not be too large as they need to be indexed by relays. Constraining the value to 253 bytes allows an entire TLV (with 16-bit type and 8-bit length) to fit within 256 bytes, which may ease implementation in some cases.","title":"Tags"},{"location":"record/#payload","text":"Varying bytes at [216+Len_t:216+Len_t+Len_p]. Payload is opaque (at this layer of specification) application-specific data. The payload section is padded out to 64-bit alignment. The maximum payload section length is 524288 bytes.","title":"Payload"},{"location":"reference/","text":"References PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references Hash Reference A hash reference is a pointer to an exact record with no provision for replacement or edits. It is a prefix of the hash of the message. Usually either a 16-byte (128 bit) or 32-byte (256 bit) prefix is used. Address Reference An address reference is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records. An address consists of four fields which are contiguous and in order in the record layout at [160:208] making up 48 bytes. The the author's public key (32 bytes), The timestamp (6 bytes), The nonce (6 bytes The application ID (4 bytes). An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key, the same timestamp, and the same application id. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed. Rationale: By containing the Author public key, record location can be determined through bootstrapping . These are 48 bytes long and easily fit into a 253 byte tag when needed. By not including the hash of content, records can be edited and replaced by the author (where edits make sense) By containing the application ID, records that are edited cannot change their type. By containing the application ID, software can filter records that are not relevant to a situation without needing to look them up first. 48 bits of randomness (in the nonce) is unique enough. The odds that a user will have multiple clients that simultaneously create records at the same millisecond and also choose the same 48-bit random number is exceedingly low given that the odds of choosing the same 48-bit random number is about 1 in 281 trillion. Normally people use 64-bit random numbers for global uniqueness, but we don't need global uniqueness, just unique for the given author at that precise millisecond in time. These addresses sort in chronological order, per author.","title":"Reference"},{"location":"reference/#references","text":"PAGE STATUS: early draft A reference is a pointer from one record to another. Mosaic defines two kinds of references","title":"References"},{"location":"reference/#hash-reference","text":"A hash reference is a pointer to an exact record with no provision for replacement or edits. It is a prefix of the hash of the message. Usually either a 16-byte (128 bit) or 32-byte (256 bit) prefix is used.","title":"Hash Reference"},{"location":"reference/#address-reference","text":"An address reference is a pointer to a group of records that have the same address, which usually represent an initial record and it's subsequent replacements, often (and by default presumably) with the most recent record superceding the older records. An address consists of four fields which are contiguous and in order in the record layout at [160:208] making up 48 bytes. The the author's public key (32 bytes), The timestamp (6 bytes), The nonce (6 bytes The application ID (4 bytes). An author can replace a record by creating a new record with the same address, in which case the address is copied (the nonce is not randomly generated). Replaced records must then contain the same author key, the same timestamp, and the same application id. They may however be signed by a different signing keypair or have their flags modified, their tags changed, and their content changed. Rationale: By containing the Author public key, record location can be determined through bootstrapping . These are 48 bytes long and easily fit into a 253 byte tag when needed. By not including the hash of content, records can be edited and replaced by the author (where edits make sense) By containing the application ID, records that are edited cannot change their type. By containing the application ID, software can filter records that are not relevant to a situation without needing to look them up first. 48 bits of randomness (in the nonce) is unique enough. The odds that a user will have multiple clients that simultaneously create records at the same millisecond and also choose the same 48-bit random number is exceedingly low given that the odds of choosing the same 48-bit random number is about 1 in 281 trillion. Normally people use 64-bit random numbers for global uniqueness, but we don't need global uniqueness, just unique for the given author at that precise millisecond in time. These addresses sort in chronological order, per author.","title":"Address Reference"},{"location":"reply_comment/","text":"Reply Comment PAGE STATUS: incomplete App ID = 0x5 - Reply Comment Flags 0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral. Tags This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3.","title":"Reply Comment"},{"location":"reply_comment/#reply-comment","text":"PAGE STATUS: incomplete App ID = 0x5 - Reply Comment","title":"Reply Comment"},{"location":"reply_comment/#flags","text":"0x01 ZSTD - may be on or off 0x02 FROMAUTHOR - may be on or off to control distribution. 0x04 TORECIPIENTS - may be on or off. 0x08 NOBRIDGE - may be on or off 0x10 EPHEMERAL- MUST be off. Reply comments are not ephemeral.","title":"Flags"},{"location":"reply_comment/#tags","text":"This MUST include exactly one reply tag, either 0x2 or 0x3. This MUST include exactly one root tag, either 0x2 or 0x3.","title":"Tags"},{"location":"rest/","text":"Mosaic over REST PAGE STATUS: TBD Unlike WebSockets (and WebTransport), servers cannot notify clients of new records over REST. Clients must instead poll.","title":"REST"},{"location":"rest/#mosaic-over-rest","text":"PAGE STATUS: TBD Unlike WebSockets (and WebTransport), servers cannot notify clients of new records over REST. Clients must instead poll.","title":"Mosaic over REST"},{"location":"status/","text":"Status and Development Page statuses Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status. Versions and Attribution Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Steve Farroll edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible. Principles of Design The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media ones. It is okay to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are optional. For example, we can have multiple transports (WebSockets, WebTransport, even REST) without all the developers needing to move beyond WebSockets. Core Library This specification is being developed in parallel to a core library. The findings from development feed back into this specification. This is to be published on github shortly.","title":"Status and Development"},{"location":"status/#status-and-development","text":"","title":"Status and Development"},{"location":"status/#page-statuses","text":"Page statuses move between these states TBD Incomplete Early Draft Draft (ready for others to review and comment on) Approved xN (N people have approved) Implemented xN (N implementations are known to exist) Superceded (some other page now supercedes this) Note that developers are encouraged to comment on and discuss pages in any status, they don't have to wait for draft status.","title":"Page statuses"},{"location":"status/#versions-and-attribution","text":"Many people are expected to contribute to Mosaic and as a result there are various divergent viewpoints as to how Mosaic ought to be. As a result, we label this edition as the Steve Farroll edition. You will see this at the bottom of every page. Other Mosaic contributors can fork this and maintain their own editions. The community will eventually settle on something because people want to be compatible.","title":"Versions and Attribution"},{"location":"status/#principles-of-design","text":"The protocol must be simple enough for multiple implementations to be developed, but simplicity is not the only factor. The protocol must be functional enough to support a wide range of applications beyond just social media ones. It is okay to do things multiple ways so long as there is one default that all developers implement, and the rest of the \"ways\" are optional. For example, we can have multiple transports (WebSockets, WebTransport, even REST) without all the developers needing to move beyond WebSockets.","title":"Principles of Design"},{"location":"status/#core-library","text":"This specification is being developed in parallel to a core library. The findings from development feed back into this specification. This is to be published on github shortly.","title":"Core Library"},{"location":"tags/","text":"Tag types PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format. Public Key (0x1) Type = 0x1 Value = A public key This tag indicates that the record is of interest to the person identified by the public key. By being tagged as such, that person can easily look up such records. Note that such records should be delivered to all of this persons' INBOX servers as specified in their bootstrap record. Reply, Hash Reference (0x2) Type = 0x2 Value = A 32-byte hash reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Hash Reference 0x4 tag as well. Reply, Address Reference (0x3) Type = 0x3 Value = A 48-byte address reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Address Reference 0x5 tag as well. Root, Hash Reference (0x4) Type = 0x4 Value = A 32-byte hash reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Hash Reference 0x2 tag as well. Root, Address Reference (0x5) Type = 0x5 Value = A 48-byte address reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Address Reference 0x3 tag as well. Quote, Hash Reference (0x6) Type = 0x6 Value = A 32-byte hash reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted. Quote, Address Reference (0x7) Type = 0x7 Value = A 48-byte address reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted.","title":"Tag Types"},{"location":"tags/#tag-types","text":"PAGE STATUS: early draft Tag types are 2-byte (16-bit) unsigned integers in little-endian format.","title":"Tag types"},{"location":"tags/#public-key-0x1","text":"Type = 0x1 Value = A public key This tag indicates that the record is of interest to the person identified by the public key. By being tagged as such, that person can easily look up such records. Note that such records should be delivered to all of this persons' INBOX servers as specified in their bootstrap record.","title":"Public Key (0x1)"},{"location":"tags/#reply-hash-reference-0x2","text":"Type = 0x2 Value = A 32-byte hash reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Hash Reference 0x4 tag as well.","title":"Reply, Hash Reference (0x2)"},{"location":"tags/#reply-address-reference-0x3","text":"Type = 0x3 Value = A 48-byte address reference This record replies to (in a threading sense) the referenced record. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Root, Address Reference 0x5 tag as well.","title":"Reply, Address Reference (0x3)"},{"location":"tags/#root-hash-reference-0x4","text":"Type = 0x4 Value = A 32-byte hash reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Hash Reference 0x2 tag as well.","title":"Root, Hash Reference (0x4)"},{"location":"tags/#root-address-reference-0x5","text":"Type = 0x5 Value = A 48-byte address reference This record replies to a thread whose root is the referenced record. This is to support loading an entire thread in one round trip. Replies are application-independent and may reference records of any type. If a record includes this tag, it must also include a Reply, Address Reference 0x3 tag as well.","title":"Root, Address Reference (0x5)"},{"location":"tags/#quote-hash-reference-0x6","text":"Type = 0x6 Value = A 32-byte hash reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted.","title":"Quote, Hash Reference (0x6)"},{"location":"tags/#quote-address-reference-0x7","text":"Type = 0x7 Value = A 48-byte address reference This indicates another record is quoted, but not as a threaded reply. Records with this tag can also have reply and root tags, but not to the same record that is quoted.","title":"Quote, Address Reference (0x7)"},{"location":"timestamps/","text":"Timestamps PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds, and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0. Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds, unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Rationale: UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). The first bit is zero in case it is ever interpreted as a sign bit, in order to preserve sorting. Millisecond unixtimes in 47 bits give us more than 4000 years before they roll over. Refer to the IANA leap second list","title":"Timestamps"},{"location":"timestamps/#timestamps","text":"PAGE STATUS: draft Timestamps are unixtimes, adjusted for leap seconds, expressed in milliseconds, and encoded into a 48-bit unsigned integer in little-endian format. The first bit is 0. Records that have a 1 bit here SHOULD be ignored. The next 47 bits represent the number of milliseconds that have actually elapsed on the surface of the Earth since the UNIX epoch. The epoch is defined as (these definitions are believed to be equivalent): 1 January 1970 UTC Unixtime 0 NTP timestamp 2208988800 Julian Date 2440587.5 UT1 Julian Date 2440587.5004766666 TT NOTE: the fracton above beyond .5 represents the 9 seconds that UTC was behind TAI, plus the 32.184 seconds that TAI is behind TT. Timestamps account for all leap seconds, unlike unixtime and unlike NTP timestamps (both of which pretend that leap seconds did not happen). Before 1 Jan 1972, timestamps match unixtime. As of this writing (unixtime 1732829887) the current timetstamp which includes 28 additional leap seconds is 1732829915. Since computers tend to be synchronized with UTC for the time being, your software will need to be aware of leap seconds so it can adjust. Leap second data is available at the IANA leap second list The data should be interpreted as follows: The leftmost column is an NTP timestamp. Subtract 2_208_988_800 from it to get a unixtime. The rightmost column is an adjustment to TAI. Subtract 9 from it to get the number of leapseconds that have elapsed as of the time in the first column and thereafter (until the next entry). A timestamp is the current unixtime, plus the number of leap seconds that have elapsed. Rationale: UTC is a discontinous time scale that is occasionally adjusted by leap seconds. Unixtime is derived from UTC and is thus also discontinuous. Subtracting two unixtimes could give a time interval that is off by up to 28 seconds (for example when comparing dates before 1 Jan 1972 with today). The first bit is zero in case it is ever interpreted as a sign bit, in order to preserve sorting. Millisecond unixtimes in 47 bits give us more than 4000 years before they roll over. Refer to the IANA leap second list","title":"Timestamps"},{"location":"websockets/","text":"Mosaic over Websockets PAGE STATUS: Incomplete TLS WebSockets transport require TLS version at least 1.2 or preferably TLS 1.3 TLS server-side certificates must be either self-signed using the server's signing key, or preferably in RawPublicKey form. Servers SHOULD request client-side certificates if they wish to authenticate users (most do). Clients MAY provide such certificates either self-signed or in RawPublicKey form, presenting their signing key. If clients do not provide such, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not. TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys. WebSockets Mosaic messages are transported over WebSockets Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Clients MAY present multiple additional protocol names (probably representing future versions of Mosaic), and servers should accept whichever one they wish. Servers MUST reply with the protocol they have accepted, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols. Binary All messages use websockets binary, and include the binary protocol message literally as specified in protocol","title":"WebSockets"},{"location":"websockets/#mosaic-over-websockets","text":"PAGE STATUS: Incomplete","title":"Mosaic over Websockets"},{"location":"websockets/#tls","text":"WebSockets transport require TLS version at least 1.2 or preferably TLS 1.3 TLS server-side certificates must be either self-signed using the server's signing key, or preferably in RawPublicKey form. Servers SHOULD request client-side certificates if they wish to authenticate users (most do). Clients MAY provide such certificates either self-signed or in RawPublicKey form, presenting their signing key. If clients do not provide such, they should be considered anonymous. Servers MAY present different services depending on whether a user is authenticated or not. TLS should specify the EdDSA signature algorithm, using the ed25519 signing keys.","title":"TLS"},{"location":"websockets/#websockets","text":"Mosaic messages are transported over WebSockets Clients must present the Sec-WebSocket-Protocol header field in the handshake with WebSocket with the value mosaic2024 . If this is not presented, a server may either refuse service and close the connection, or presume the connection is nostr (if it is dual-stack). It should not presume the connection is Mosaic. Clients MAY present multiple additional protocol names (probably representing future versions of Mosaic), and servers should accept whichever one they wish. Servers MUST reply with the protocol they have accepted, at this point being only 'mosaic2024'. This subprotocol is not (as of this writing) registered with IANA, but does not conflict with registered subprotocols.","title":"WebSockets"},{"location":"websockets/#binary","text":"All messages use websockets binary, and include the binary protocol message literally as specified in protocol","title":"Binary"},{"location":"webtransport/","text":"Mosaic over Webtransport PAGE STATUS: TBD Intend to specify a subprotocol in the websockets HTTP header","title":"WebTransport"},{"location":"webtransport/#mosaic-over-webtransport","text":"PAGE STATUS: TBD Intend to specify a subprotocol in the websockets HTTP header","title":"Mosaic over Webtransport"}]}